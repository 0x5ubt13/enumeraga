
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>checks: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/0x5ubt13/enumeraga/internal/checks/checks.go (0.0%)</option>
				
				<option value="file1">github.com/0x5ubt13/enumeraga/internal/cloud/cloud.go (0.0%)</option>
				
				<option value="file2">github.com/0x5ubt13/enumeraga/internal/cloudScanner/cloudScanner.go (0.0%)</option>
				
				<option value="file3">github.com/0x5ubt13/enumeraga/internal/commands/commands.go (0.0%)</option>
				
				<option value="file4">github.com/0x5ubt13/enumeraga/internal/config/cloud_config.go (0.0%)</option>
				
				<option value="file5">github.com/0x5ubt13/enumeraga/internal/infra/infra.go (43.3%)</option>
				
				<option value="file6">github.com/0x5ubt13/enumeraga/internal/portsIterator/portsIterator.go (0.0%)</option>
				
				<option value="file7">github.com/0x5ubt13/enumeraga/internal/scans/scans.go (0.0%)</option>
				
				<option value="file8">github.com/0x5ubt13/enumeraga/internal/utils/utils.go (17.8%)</option>
				
				<option value="file9">github.com/0x5ubt13/enumeraga/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package checks

import (
        "fmt"
        "github.com/0x5ubt13/enumeraga/internal/cloud"
        "github.com/0x5ubt13/enumeraga/internal/infra"
        "github.com/0x5ubt13/enumeraga/internal/utils"
        "github.com/pborman/getopt/v2"
        "os"
)

var (
        // DEV: initialising vars only once they have been implemented/ported in the code
        // optAgain         = getopt.BoolLong("again", 'a', "Repeat the scan and compare with initial ports discovered.")

        // OptBrute Activates all fuzzing and bruteforce in the script
        OptBrute = getopt.BoolLong("brute", 'b', "Activate all fuzzing and bruteforce in the tool.")

        // Specify custom DNS servers.
        // Default option: -n
        // OptDNS                 = getopt.StringLong("DNS", 'd', "", "Specify custom DNS servers. Default option: -n")

        // OptHelp displays help dialogue and exit
        OptHelp = getopt.BoolLong("help", 'h', "Display this help and exit.")

        // OptInstall Only try to install pre-requisite tools and exit
        OptInstall = getopt.BoolLong("install", 'i', "Only try to install pre-requisite tools and exit.")

        // OptNmapOnly only runs nmap, ignoring all tools prerequisites
        OptNmapOnly = getopt.BoolLong("nmap-only", 'n', "Activate nmap scans only in Enumeraga and ignore all other tools, including their installation.")

        // OptOutput selects a different base folder for the output
        // Default option: "/tmp/enumeraga_output"
        OptOutput = getopt.StringLong("output", 'o', "/tmp/enumeraga_output", "Select a different base folder for the output.")

        // OptTopPorts runs port sweep with nmap and the flag --top-ports=&lt;your input&gt;
        OptTopPorts = getopt.StringLong("top-ports", 'p', "", "Run port sweep with nmap and the flag --top-ports=&lt;your input&gt;")

        // OptQuiet makes the tool not print the banner and decreases the overall verbosity
        OptQuiet = getopt.BoolLong("quiet", 'q', "Don't print the banner and decrease overall verbosity.")

        // OptRange specifies a CIDR range to use tools for whole subnets
        OptRange = getopt.StringLong("range", 'r', "", "Specify a CIDR range to use tools for whole subnets.")

        // OptTarget specifies a single IP target or a file with a list of IPs.
        OptTarget = getopt.StringLong("target", 't', "", "Specify target single IP / List of IPs file.")

        // OptVVerbose floods your terminal with plenty of verbosity!
        OptVVerbose = getopt.BoolLong("vv", 'V', "Flood your terminal with plenty of verbosity!")

        // Adding placeholder for OptVhost
        // OptVhost = getopt.StringLong("", '', "", "")
)

// Run pre-flight checks and return total lines if multi-target
func Run() int <span class="cov0" title="0">{
        // Set current version
        utils.Version = "v0.2.0-beta"

        // Check if infra flow or cloud flow apply
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                utils.ErrorMsg("You need to choose between `enumeraga infra` or `enumeraga cloud`")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">switch os.Args[1] </span>{
        case "c", "cl", "clo", "clou", "cloud":<span class="cov0" title="0">
                fmt.Printf("\n%s%s%s\n", utils.Cyan("[*] ---------- "), utils.Green("Starting Cloud checks phase"), utils.Cyan(" ----------"))

                cloud.Run(OptOutput, OptHelp, OptQuiet, OptVVerbose)</span>
        case "i", "in", "inf", "infr", "infra":<span class="cov0" title="0">
                // Infra checks now moved to internal/infra/infra.go
                return infra.Run(OptHelp, OptInstall, OptNmapOnly, OptQuiet, OptVVerbose, OptOutput, OptTarget)</span>

        default:<span class="cov0" title="0">
                utils.ErrorMsg("You need to choose between `enumeraga infra` or `enumeraga cloud`")
                os.Exit(1)</span>
        }

        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cloud

import (
        "fmt"
        "github.com/0x5ubt13/enumeraga/internal/cloudScanner"
        "github.com/0x5ubt13/enumeraga/internal/utils"
        "github.com/pborman/getopt/v2"
        "os"
        "time"
)


// Run launches the main entrypoint for enumeraga cloud
func Run(OptOutput *string, OptHelp, OptQuiet, OptVVerbose *bool) <span class="cov0" title="0">{
        // Timing the execution
        start := time.Now()

        // Cloud flow must end when this Run function finishes
        defer os.Exit(0)

        // Parse optional cloud arguments, getting rid of the `enumeraga cloud` args
        // Keep os.Args[0] as program name for getopt, remove "cloud" subcommand
        os.Args = append(os.Args[:1], os.Args[2:]...)
        getopt.Parse()

        // Assign basedir of OptOutput to avoid cyclic import hell
        utils.BaseDir = *OptOutput

        // Check 0: banner!
        if !*OptQuiet </span><span class="cov0" title="0">{
                utils.PrintBanner()
        }</span>

        // Check 1: Help flag passed?
        <span class="cov0" title="0">if *OptHelp </span><span class="cov0" title="0">{
                if !*OptQuiet </span><span class="cov0" title="0">{
                        fmt.Println(utils.Cyan("[*] Help flag detected. Aborting other checks and printing usage.\n"))
                }</span>
                <span class="cov0" title="0">printCloudUsage()
                utils.PrintCloudUsageExamples()
                os.Exit(0)</span>
        }

        // Get remaining args after flag parsing
        <span class="cov0" title="0">remainingArgs := getopt.Args()

        // Check 2: Args passed fine?
        if len(remainingArgs) == 0 </span><span class="cov0" title="0">{
                utils.ErrorMsg("No arguments were provided.")
                printCloudUsage()
                utils.PrintCloudUsageExamples()
                os.Exit(1)
        }</span>

        // Check 3: Ensure there is a valid CSP target
        <span class="cov0" title="0">provider, err := parseCSP(remainingArgs[0])
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(err)
                os.Exit(1)
        }</span>

        // Check 4: I AM GROOT!!!!
        <span class="cov0" title="0">utils.CheckAdminPrivileges("cloud")

        // Check 5: Ensure base output directory is correctly set and exists
        name, err := utils.CustomMkdir(*OptOutput)
        if err != nil </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        utils.ErrorMsg(err)
                }</span>
        }

        <span class="cov0" title="0">if !*OptQuiet </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("green", "yellow", "[+] Using '", name, "' as base directory to save the ", "cloud output ", "files")
        }</span>

        // Checks done
        <span class="cov0" title="0">if !*OptQuiet </span><span class="cov0" title="0">{
                fmt.Printf("%s%s%s\n\n", utils.Cyan("[*] ---------- "), utils.Green("Checks phase complete"), utils.Cyan(" ----------"))
                fmt.Printf("%s%s%s\n", utils.Cyan("[*] ---------- "), utils.Green("Starting enumeration phase"), utils.Cyan(" ----------"))
        }</span>

        // Scan start: changing into cloudScanner's Run function
        <span class="cov0" title="0">cloudScanner.Run(provider, OptVVerbose)

        // Finish and show elapsed time
        utils.FinishLine(start, utils.Interrupted)

        // Wait for goroutines to finish to terminate the program
        utils.Wg.Wait()</span>
}

// printCloudUsage prints only the cloud-relevant flags, not infra flags
func printCloudUsage() <span class="cov0" title="0">{
        fmt.Println("Usage: enumeraga cloud [OPTIONS] &lt;provider&gt;")
        fmt.Println("\nCloud Providers:")
        fmt.Println("  aws, amazon          Amazon Web Services")
        fmt.Println("  azure, az            Microsoft Azure")
        fmt.Println("  gcp, gcloud, g       Google Cloud Platform")
        fmt.Println("  oci, oracle          Oracle Cloud Infrastructure")
        fmt.Println("  aliyun, alibaba      Alibaba Cloud")
        fmt.Println("  do, digitalocean     DigitalOcean")
        fmt.Println("\nOptions:")
        fmt.Println("  -h, --help           Display this help and exit")
        fmt.Println("  -o, --output DIR     Select a different base folder for output (default: /tmp/enumeraga_output)")
        fmt.Println("  -q, --quiet          Don't print the banner and decrease overall verbosity")
        fmt.Println("  -V, --vv             Flood your terminal with plenty of verbosity!")
        fmt.Println()
}</span>

// parseCSP parses the provider the user wants to enumerate
func parseCSP(provider string) (string, error) <span class="cov0" title="0">{
        possibleProviders := []string{"aws", "azure", "gcp", "oci", "aliyun", "digitalocean (do)"}

        switch provider </span>{
        case "aws", "amazon":<span class="cov0" title="0">
                provider = "aws"</span>
        case "az", "azure":<span class="cov0" title="0">
                provider = "azure"</span>
        case "gcp", "gcloud", "g":<span class="cov0" title="0">
                provider = "gcp"</span>
        case "ay", "ali", "aliy", "aliyun", "alibaba":<span class="cov0" title="0">
                provider = "aliyun"</span>
        case "oci", "oracle":<span class="cov0" title="0">
                provider = "oci"</span>
        case "do", "digital", "digitalocean":<span class="cov0" title="0">
                provider = "do"</span>
        default:<span class="cov0" title="0">
                utils.ErrorMsg(fmt.Sprintf("%s not detected as a suitable cloud service provider. Please try again by using one of these: %v.", provider, possibleProviders))
                return "", fmt.Errorf("no suitable cloud service provider parsed")</span>
        }

        <span class="cov0" title="0">utils.PrintCustomBiColourMsg("green", "yellow", "[+] Using '", provider, "' as provider to launch scans")
        return provider, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cloudScanner

import (
        "fmt"
        "github.com/0x5ubt13/enumeraga/internal/commands"
        "github.com/0x5ubt13/enumeraga/internal/utils"
        "os"
)

func Run(provider string, OptVVerbose *bool) <span class="cov0" title="0">{
        providerDir := fmt.Sprintf("%s/%s/", utils.BaseDir, provider)
        _, err := utils.CustomMkdir(providerDir)
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(err)
        }</span>
        <span class="cov0" title="0">fmt.Println(utils.Debug("[?] Debug -&gt; providerDir = ", providerDir))

        // Launch scoutsuite's function inside commands.
        //TODO: think: change to goroutine??? Probs too much smashing the cloud provider??
        // Add more tools here, then complete switch case in commands.PrepCloudTool()
        runTool("scoutsuite", provider, fmt.Sprintf("%sscoutsuite/", providerDir), OptVVerbose)
        runTool("prowler", provider, fmt.Sprintf("%sprowler/", providerDir), OptVVerbose)
        runTool("cloudfox", provider, fmt.Sprintf("%scloud_fox/", providerDir), OptVVerbose)
        runTool("kubenumerate", provider, fmt.Sprintf("%skubenumerate/", providerDir), OptVVerbose)
        // runTool("cloudsplaining, provider, fmt.Sprintf("%scloud_peass/", providerDir), OptVVerbose)") // https://github.com/salesforce/cloudsplaining
        
        // Tried AWSPeass.py and while it's great, I need to figure out how to run it programatically as it prompts for input from time to time
        // runTool("cloudpeass, provider, fmt.Sprintf("%scloud_peass/", providerDir), OptVVerbose)")

        // commands.Steampipe()
        
        // commands.Powerpipe()
        // if GCP:
        // commands.GCPwn()
        // if AWS:
        // commands.Pacu()???

        // Leaving pmapper out for now as I can't manage to make conda work inside a container and pmapper needs python 3.8
        // runTool("pmapper", provider, fmt.Sprintf("%spmapper/", providerDir), OptVVerbose)
        
        os.Exit(0)</span>
}

// runTool runs the specified tool
func runTool(tool, provider, path string, OptVVerbose *bool) <span class="cov0" title="0">{
        // Ensure path exists before continuing
        _, err := utils.CustomMkdir(path)
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(err)
        }</span>

        // Change to internal/commands
        <span class="cov0" title="0">toolErr := commands.PrepCloudTool(tool, path, provider, OptVVerbose)
        if toolErr != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(toolErr)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package commands

import (
        "bufio"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/0x5ubt13/enumeraga/internal/config"
        "github.com/0x5ubt13/enumeraga/internal/scans"
        "github.com/0x5ubt13/enumeraga/internal/types"
        "github.com/0x5ubt13/enumeraga/internal/utils"
        "github.com/xuri/excelize/v2"
)

// WPEnumeration provides enumeration for WordPress
func WPEnumeration(targetUrl, caseDir, port string, OptVVerbose *bool) <span class="cov0" title="0">{
        // Identify WordPress: Run curl
        curl := exec.Command("curl", "-s", "-X", "GET", targetUrl)
        curlOutput, err := curl.Output()
        if err != nil </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        utils.ErrorMsg(fmt.Sprintf("Failed to curl target for WordPress detection: %v", err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // grep 'wp-content'
        <span class="cov0" title="0">if !strings.Contains(string(curlOutput), "wp-content") </span><span class="cov0" title="0">{
                return
        }</span>

        // Detected, prepare to run wpscan
        <span class="cov0" title="0">utils.PrintCustomBiColourMsg("yellow", "cyan", "[!]", "WordPress detected. Running", "WPScan", "...")
        wpScanArgs := []string{"wpscan", "--url", targetUrl, "-e", "p,u"}
        wpScanPath := fmt.Sprintf("%swpscan_%s.out", caseDir, port)
        runTool(wpScanArgs, wpScanPath, OptVVerbose)</span>
}

func tomcatEnumeration(target, targetUrl, caseDir, port string, OptBrute *bool, OptVVerbose *bool) <span class="cov0" title="0">{
        // Identify Tomcat: Run curl
        curl := exec.Command("curl", "-s", "-X", "GET", targetUrl)
        curlOutput, err := curl.Output()
        if err != nil </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        utils.ErrorMsg(fmt.Sprintf("Failed to curl target for Tomcat detection: %v", err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // grep 'tomcat'
        <span class="cov0" title="0">if !strings.Contains(strings.ToLower(string(curlOutput)), "tomcat") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">utils.PrintCustomBiColourMsg("yellow", "cyan", "[!]", "Tomcat detected. Running", "Gobuster", "...")

        // Run Gobuster
        gobusterArgs := []string{"gobuster", "-z", "-q", "dir", "-e", "-u", fmt.Sprintf("%s:%s", target, port), "-w", utils.DirListMedium}
        gobusterPath := fmt.Sprintf("%stomcat_gobuster.out", caseDir)
        CallRunTool(gobusterArgs, gobusterPath, OptVVerbose)

        // Run hydra
        if !*OptBrute </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">hydraArgs := []string{
                "hydra",
                "-L", utils.UsersList,
                "-P", utils.DarkwebTop1000,
                "-f", target,
                "http-get", "/manager/html",
        }
        hydraPath := fmt.Sprintf("%stomcat_hydra.out", caseDir)
        CallRunTool(hydraArgs, hydraPath, OptVVerbose)</span>
}

func runCewlandFfufKeywords(target, caseDir, port string, OptVVerbose *bool) <span class="cov0" title="0">{
        if port == "80" </span><span class="cov0" title="0">{
                keywordsList := fmt.Sprintf("%scewl_keywordslist_80.out", caseDir)
                targetURL := fmt.Sprintf("http://%s:80", target)
                cewlArgs := []string{"cewl", "-m7", "--lowercase", "-w", keywordsList, targetURL}
                cewlPath := fmt.Sprintf("%scewl_80.out", caseDir)
                runTool(cewlArgs, cewlPath, OptVVerbose)

                ffufArgs := []string{
                        "ffuf",
                        "-w", fmt.Sprintf("%s:FOLDERS,%s:KEYWORDS,%s:EXTENSIONS", utils.DirListMedium, keywordsList, utils.ExtensionsList),
                        "-u", fmt.Sprintf("http://%s/FOLDERS/KEYWORDSEXTENSIONS", target),
                        "-v",
                        "-maxtime", "300",
                        "-maxtime-job", "300",
                }
                fmt.Println(utils.Debug("[?] Debug: ffuf keywords command:", ffufArgs))
                ffufPath := fmt.Sprintf("%sffuf_keywords_80.out", caseDir)
                runTool(ffufArgs, ffufPath, OptVVerbose)
                return
        }</span>

        <span class="cov0" title="0">keywordsList := fmt.Sprintf("%scewl_keywordslist_433.out", caseDir)
        targetURL := fmt.Sprintf("http://%s:443", target)
        cewlArgs := []string{"cewl", "-m7", "--lowercase", "-w", keywordsList, targetURL}
        cewlPath := fmt.Sprintf("%scewl_443.out", caseDir)
        runTool(cewlArgs, cewlPath, OptVVerbose)

        ffufArgs := []string{
                "ffuf",
                "-w", fmt.Sprintf("%s:FOLDERS,%s:KEYWORDS,%s:EXTENSIONS", utils.DirListMedium, keywordsList, utils.ExtensionsList),
                "-u", fmt.Sprintf("http://%s/FOLDERS/KEYWORDSEXTENSIONS", target),
                "-v",
                "-maxtime", "300",
                "-maxtime-job", "300",
        }
        ffufPath := fmt.Sprintf("%sffuf_keywords_443.out", caseDir)
        runTool(ffufArgs, ffufPath, OptVVerbose)</span>
}

func printToolSuccess(command, tool, filePath string) <span class="cov0" title="0">{
        if strings.Contains(command, "80") </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("green", "cyan", "[+] Done! '", fmt.Sprintf("%s on port 80", tool), "' finished successfully")
                fmt.Println(utils.Yellow("\tShortcut: less -R"), utils.Cyan(filePath))
                return
        }</span>

        <span class="cov0" title="0">if strings.Contains(command, "443") </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("green", "cyan", "[+] Done! '", fmt.Sprintf("%s on port 443", tool), "' finished successfully")
                fmt.Println(utils.Yellow("\tShortcut: less -R"), utils.Cyan(filePath))
                return
        }</span>

        <span class="cov0" title="0">utils.PrintCustomBiColourMsg("green", "cyan", "[+] Done! '", tool, "' finished successfully")
        fmt.Println(utils.Yellow("\tShortcut: less -R"), utils.Cyan(filePath))</span>
}

// Handle messages for HTTP tools to avoid confusion
func announceTool(command, tool string) <span class="cov0" title="0">{
        if strings.Contains(command, "80") </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("yellow", "cyan", "[!] Running '", fmt.Sprintf("%s on port 80", tool), "' and sending it to the background")
        }</span>

        <span class="cov0" title="0">if strings.Contains(command, "443") </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("yellow", "cyan", "[!] Running '", fmt.Sprintf("%s on port 443", tool), "' and sending it to the background")
        }</span>

        <span class="cov0" title="0">if !strings.Contains(command, "80") &amp;&amp; !strings.Contains(command, "443") </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("yellow", "cyan", "[!] Running '", tool, "' and sending it to the background")
        }</span>
}

// Handle messages for HTTP tools to avoid confusion
func announceCloudTool(tool string) <span class="cov0" title="0">{
        utils.PrintCustomBiColourMsg("yellow", "cyan", "[!] Running '", tool, "'. Please wait...")
}</span>

// Announce tool and run it
func runTool(args []string, filePath string, OptVVerbose *bool) <span class="cov0" title="0">{
        tool := args[0]
        cmdArgs := args[1:]
        command := strings.Join(cmdArgs, " ")
        announceTool(command, tool)

        cmd := exec.Command(tool, cmdArgs...)

        // Create a pipe to capture the command's output
        stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Error creating stdout pipe: %s", err))
                os.Exit(1)
        }</span>

        // Create a file to write the output to
        <span class="cov0" title="0">file, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Error creating output file: %s", err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">defer func(file *os.File) </span><span class="cov0" title="0">{
                err := file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        utils.ErrorMsg(fmt.Sprintf("Error closing file: %s", err))
                }</span>
        }(file)

        // Start the command asynchronously in a goroutine
        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Error starting command %s: %v", tool, err))
                return
        }</span>

        // Capture and write the command's output to a file synchronously
        <span class="cov0" title="0">_, err = io.Copy(file, stdout)
        if err != nil </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        utils.ErrorMsg(fmt.Sprintf("Error copying output for tool %s: %s", tool, err))
                }</span>
        }

        // Wait for the command to complete
        <span class="cov0" title="0">if err := cmd.Wait(); err != nil </span><span class="cov0" title="0">{
                if tool == "nikto" || tool == "fping" </span><span class="cov0" title="0">{
                        // Nikto and fping don't have a clean exit
                        utils.PrintCustomBiColourMsg("green", "cyan", "[+] Done! '", tool, "' finished successfully")
                        if filePath != "/dev/null" </span><span class="cov0" title="0">{
                                fmt.Println(utils.Yellow("\tShortcut: less -R"), utils.Cyan(filePath))
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println(utils.Red("Command"), tool, utils.Red("finished with error:"), utils.Red(err))
                }</span>
        }

        <span class="cov0" title="0">printToolSuccess(command, tool, filePath)</span>
}

// RunRangeTools enumerates a whole CIDR range using specific range tools
func RunRangeTools(targetRange string, OptVVerbose *bool, OptOutput *string) <span class="cov0" title="0">{
        // Validate CIDR range before proceeding
        if err := utils.ValidateCIDR(targetRange); err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Invalid CIDR range provided: %v", err))
                return
        }</span>

        // Print Flag detected
        <span class="cov0" title="0">utils.PrintCustomBiColourMsg("cyan", "yellow", "[*] ", "-r", " flag detected. Proceeding to scan CIDR range with dedicated range enumeration tools.")

        // Make CIDR dir
        cidrDir := fmt.Sprintf("%s/%s_range_enum/", *OptOutput, strings.Replace(targetRange, "/", "_", 1))
        _, err := utils.CustomMkdir(cidrDir)
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg("error trying to make dir")
        }</span>

        // Get wordlists for the range
        <span class="cov0" title="0">utils.GetWordlists(OptVVerbose)

        // run nbtscan-unixwiz
        nbtscanArgs := []string{"nbtscan-unixwiz", "-f", targetRange}
        nbtscanPath := fmt.Sprintf("%snbtscan-unixwiz.out", cidrDir)
        CallRunTool(nbtscanArgs, nbtscanPath, OptVVerbose)

        // run Responder-RunFinger
        responderArgs := []string{"responder-RunFinger", "-i", targetRange}
        responderPath := fmt.Sprintf("%srunfinger.out", cidrDir)
        CallRunTool(responderArgs, responderPath, OptVVerbose)

        // run OneSixtyOne
        oneSixtyOneArgs := []string{"onesixtyone", "-c", utils.UsersList, targetRange, "-w", "100"}
        oneSixtyOnePath := fmt.Sprintf("%sonesixtyone.out", cidrDir)
        CallRunTool(oneSixtyOneArgs, oneSixtyOnePath, OptVVerbose)

        // run fping
        fpingArgs := []string{"fping", "-asgq", targetRange}
        fpingPath := fmt.Sprintf("%sfping.out", cidrDir)
        CallRunTool(fpingArgs, fpingPath, OptVVerbose)

        // run Metasploit scan module for EternalBlue
        answer := utils.OSCPConsent("Metasploit")
        if answer == 'n' </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">msfEternalBlueArgs := []string{"msfconsole", "-q", "-x", fmt.Sprintf("use scanner/smb/smb_ms17_010;set rhosts %s;set threads 10;run;exit", targetRange)}
        msfEternalBluePath := fmt.Sprintf("%seternalblue_sweep.txt", cidrDir)
        callEternalBlueSweepCheck(msfEternalBlueArgs, msfEternalBluePath, cidrDir, OptVVerbose)</span>
}

// eternalBlueSweepCheck is a wee fun module to detect quite low-hanging fruit
func eternalBlueSweepCheck(msfEternalBlueArgs []string, msfEternalBluePath, dir string, OptVVerbose *bool) <span class="cov0" title="0">{
        // Run msf recon first
        runTool(msfEternalBlueArgs, msfEternalBluePath, OptVVerbose)

        var confirmedVuln = false

        // Check how many of them are likely
        file, err := os.Open(msfEternalBluePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer func(file *os.File) </span><span class="cov0" title="0">{
                err := file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        utils.ErrorMsg(fmt.Sprintf("Error closing file: %s", err))
                }</span>
        }(file)

        <span class="cov0" title="0">confirmedFile := fmt.Sprintf("%seternalblue_confirmed.txt", dir)
        confirmed, err := os.Create(confirmedFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return
        }</span>
        <span class="cov0" title="0">defer func(confirmed *os.File) </span><span class="cov0" title="0">{
                err := confirmed.Close()
                if err != nil </span><span class="cov0" title="0">{
                        utils.ErrorMsg(fmt.Sprintf("Error closing file: %s", err))
                }</span>
        }(confirmed)

        <span class="cov0" title="0">scanner := bufio.NewScanner(file)
        if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Error while creating new scanner on file %s: %s", msfEternalBluePath, err))
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                // Grep -i likely
                if strings.Contains(strings.ToLower(line), "likely") </span><span class="cov0" title="0">{
                        confirmedVuln = true
                        _, err := confirmed.WriteString(line + "\n")
                        if err != nil </span><span class="cov0" title="0">{
                                utils.ErrorMsg(fmt.Sprintf("Error writing string: %s", err))
                                return
                        }</span>
                }
        }

        <span class="cov0" title="0">if !confirmedVuln </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("red", "cyan", "[-] No matches", "&lt;- Metasploit module for EternalBlue")
                return
        }</span>

        <span class="cov0" title="0">utils.PrintCustomBiColourMsg("green", "cyan", "[+] Positive Match! IPs vulnerable to ", "EternalBlue", " !\n\tShortcut: '", fmt.Sprintf("less -R %s", confirmedFile), "'")</span>
}

// Goroutine for eternalBlueSweepCheck()
func callEternalBlueSweepCheck(msfEternalBlueArgs []string, msfEternalBluePath, dir string, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.Wg.Add(1)

        go func(msfEternalBlueArgs []string, msfEternalBluePath, dir string) </span><span class="cov0" title="0">{
                defer utils.Wg.Done()

                eternalBlueSweepCheck(msfEternalBlueArgs, msfEternalBluePath, dir, OptVVerbose)
        }</span>(msfEternalBlueArgs, msfEternalBluePath, dir)
}

func CallWPEnumeration(targetUrl, caseDir, port string, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.Wg.Add(1)

        go func(targetUrl, caseDir, port string, OptVVerbose *bool) </span><span class="cov0" title="0">{
                defer utils.Wg.Done()

                WPEnumeration(targetUrl, caseDir, port, OptVVerbose)
        }</span>(targetUrl, caseDir, port, OptVVerbose)
}

func CallTomcatEnumeration(target, targetUrl, caseDir, port string, OptBrute, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.Wg.Add(1)

        go func(target, targetUrl, caseDir, port string, OptBrute, OptVVerbose *bool) </span><span class="cov0" title="0">{
                defer utils.Wg.Done()

                tomcatEnumeration(target, targetUrl, caseDir, port, OptBrute, OptVVerbose)
        }</span>(target, targetUrl, caseDir, port, OptBrute, OptVVerbose)
}

// CallRunCewlandFfufKeywords is a Goroutine for runCewlandFfufKeywords()
func CallRunCewlandFfufKeywords(target, caseDir, port string, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.Wg.Add(1)

        go func(target, caseDir, port string, OptVVerbose *bool) </span><span class="cov0" title="0">{
                defer utils.Wg.Done()

                runCewlandFfufKeywords(target, caseDir, port, OptVVerbose)
        }</span>(target, caseDir, port, OptVVerbose)
}

// CallRunTool is a Goroutine for runTool()
func CallRunTool(args []string, filePath string, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.Wg.Add(1)

        go func(args []string, filePath string, OptVVerbose *bool) </span><span class="cov0" title="0">{
                defer utils.Wg.Done()

                runTool(args, filePath, OptVVerbose)
        }</span>(args, filePath, OptVVerbose)
}

// CallIndividualPortScannerWithNSEScripts is a Goroutine for individualPortScannerWithNSEScripts()
func CallIndividualPortScannerWithNSEScripts(target, port, outFile, scripts string, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.Wg.Add(1)

        go func(target, port, outFile, scripts string, OptVVerbose *bool) </span><span class="cov0" title="0">{
                defer utils.Wg.Done()

                scans.IndividualPortScannerWithNSEScripts(target, port, outFile, scripts, OptVVerbose)
        }</span>(target, port, outFile, scripts, OptVVerbose)
}

// CallIndividualPortScannerWithNSEScriptsAndScriptArgs is a Goroutine for scans.IndividualPortScannerWithNSEScriptsAndScriptArgs()
func CallIndividualPortScannerWithNSEScriptsAndScriptArgs(target, port, outFile, scripts string, scriptArgs map[string]string, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.Wg.Add(1)

        go func(target, port, outFile, scripts string, scriptArgs map[string]string, OptVVerbose *bool) </span><span class="cov0" title="0">{
                defer utils.Wg.Done()

                utils.PrintCustomBiColourMsg("yellow", "cyan", "[!] Starting nmap scan against port(s) '", port, "' on target '", target, "' and sending it to the background")
                scans.IndividualPortScannerWithNSEScriptsAndScriptArgs(target, port, outFile, scripts, scriptArgs, OptVVerbose)
        }</span>(target, port, outFile, scripts, scriptArgs, OptVVerbose)
}

// CallIndividualUDPPortScannerWithNSEScripts is a Goroutine for scans.IndividualUDPPortScannerWithNSEScripts()
func CallIndividualUDPPortScannerWithNSEScripts(target, port, outFile, scripts string, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.Wg.Add(1)

        go func(target, port, outFile, scripts string, OptVVerbose *bool) </span><span class="cov0" title="0">{
                defer utils.Wg.Done()

                scans.IndividualUDPPortScannerWithNSEScripts(target, port, outFile, scripts, OptVVerbose)
        }</span>(target, port, outFile, scripts, OptVVerbose)
}

// CallIndividualPortScanner is a Goroutine for scans.IndividualPortScanner()
func CallIndividualPortScanner(target, port, outFile string, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.Wg.Add(1)

        go func(target, port, outFile string, OptVVerbose *bool) </span><span class="cov0" title="0">{
                defer utils.Wg.Done()

                scans.IndividualPortScanner(target, port, outFile, OptVVerbose)
        }</span>(target, port, outFile, OptVVerbose)
}

// CallFullAggressiveScan is a Goroutine for scans.FullAggressiveScan()
func CallFullAggressiveScan(target, ports, outFile string, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.Wg.Add(1)

        go func(target, ports, outFile string, OptVVerbose *bool) </span><span class="cov0" title="0">{
                defer utils.Wg.Done()

                utils.PrintCustomBiColourMsg("yellow", "cyan", "[!] Starting ", "main aggressive nmap scan ", "against all open ports on'", target, "' and sending it to the background")
                ports = ports + ",1337" // Adding one likely closed port for OS fingerprinting purposes
                scans.FullAggressiveScan(target, ports, outFile, OptVVerbose)
        }</span>(target, ports, outFile, OptVVerbose)
}

/* --------------------------------
   |  Cloud enumeration commands  |
   -------------------------------- */

// InstallWithPipxOSAgnostic installs a pipx in any supported OS
func InstallWithPipxOSAgnostic(tool string) error <span class="cov0" title="0">{
        // Check pipx is not there in the first place just in case
        if !utils.CheckToolExists("pipx") </span><span class="cov0" title="0">{
                fmt.Println("Installing pipx")

                switch utils.HostOS.OS </span>{
                case "windows":<span class="cov0" title="0">
                        // Use PowerShell to install pipx on Windows
                        cmd := exec.Command("powershell", "-Command", "iwr https://bootstrap.pypa.io/get-pip.py -OutFile get-pip.py; python get-pip.py; pip install pipx; pipx ensurepath")
                        cmd.Stdout = os.Stdout
                        cmd.Stderr = os.Stderr
                        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error installing pipx on Windows: %v", err)
                        }</span>
                case "darwin":<span class="cov0" title="0">
                        // Use Homebrew to install pipx on macOS
                        cmd := exec.Command("/bin/sh", "-c", "brew install pipx")
                        cmd.Stdout = os.Stdout
                        cmd.Stderr = os.Stderr
                        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error installing pipx on macOS: %v", err)
                        }</span>
                case "linux":<span class="cov0" title="0">
                        // Use apt-get to install pipx on Linux
                        utils.AptGetUpdateCmd()
                        utils.AptGetInstallCmd("pipx")</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unsupported operating system")</span>
                }
        }

        <span class="cov0" title="0">command := fmt.Sprintf("pipx install %s", tool)
        var cmd *exec.Cmd
        if utils.HostOS.OS == "windows" </span><span class="cov0" title="0">{
                cmd = exec.Command("powershell", "-Command", command)
        }</span> else<span class="cov0" title="0"> {
                cmd = exec.Command("/bin/sh", "-c", command)
        }</span>
        <span class="cov0" title="0">cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        return cmd.Run()</span>
}

// PrepCloudTool preps the program to run a cloud tool
// To add more cloud enumeration capabilities, add new switch cases here
func PrepCloudTool(tool, filePath, provider string, OptVVerbose *bool) error <span class="cov0" title="0">{
        var commandToRun string

        // Get name of the tool first
        switch tool </span>{
        case "scoutsuite":<span class="cov0" title="0">
                if !utils.CheckToolExists("scout") </span><span class="cov0" title="0">{
                        err := InstallWithPipxOSAgnostic("scoutsuite")
                        if err != nil </span><span class="cov0" title="0">{
                                utils.PrintCustomBiColourMsg("red", "cyan", "[-]", "Error installing scout via pipx")
                                return err
                        }</span>
                }

                // TODO: add flags to pass azure creds?
                <span class="cov0" title="0">commandToRun = fmt.Sprintf("scout %s --no-browser --report-dir %s", provider, filePath)</span>

        case "prowler":<span class="cov0" title="0">
                if !utils.CheckToolExists("prowler") </span><span class="cov0" title="0">{
                        err := InstallWithPipxOSAgnostic("prowler")
                        if err != nil </span><span class="cov0" title="0">{
                                utils.PrintCustomBiColourMsg("red", "cyan", "[-]", "Error installing prowler via pipx")
                                return err
                        }</span>
                }
                <span class="cov0" title="0">commandToRun = fmt.Sprintf("prowler %s -o %s", provider, filePath)</span>

        case "cloudfox":<span class="cov0" title="0">
                if !utils.CheckToolExists("cloudfox") </span><span class="cov0" title="0">{
                        utils.PrintCustomBiColourMsg("red", "yellow", "[-] CloudFox ", "not found. Attempting to download it now from GitHub...")
                        binaryPath, err := utils.DownloadFromGithubAndInstall("cloudfox")
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error downloading cloudfox: %v", err)
                        }</span>

                        <span class="cov0" title="0">commandToRun = fmt.Sprintf("%s %s all-checks --outdir %s", binaryPath, provider, filePath)</span>
                } else<span class="cov0" title="0"> {
                        commandToRun = fmt.Sprintf("cloudfox %s all-checks --outdir %s", provider, filePath)
                }</span>

        case "pmapper":<span class="cov0" title="0">
                if provider != "aws" </span><span class="cov0" title="0">{
                        utils.PrintCustomBiColourMsg("red", "yellow", "[-]", " PMapper ", "only supports", " AWS ", ". Skipping it...")
                        break</span>
                }

                // // Run conda init
                // condaErr := exec.Command("conda", "init", "bash")
                // if condaErr != nil {
                //         return fmt.Errorf("error running conda init: %v", condaErr)
                // }

                <span class="cov0" title="0">commandToRun = fmt.Sprintf("source /opt/conda/etc/profile.d/conda.sh &amp;&amp; conda init bash &amp;&amp; conda activate pmapper &amp;&amp; export PRINCIPALMAPPER_DATA_DIR=%s &amp;&amp; pmapper graph create", filePath)</span>
        case "kubenumerate":<span class="cov0" title="0">
                if provider != "k8s" </span><span class="cov0" title="0">{
                        utils.PrintCustomBiColourMsg("red", "yellow", "[-]", " Kubenumerate ", "must be run with the", " k8s ", "flag. Skipping it...")
                        break</span>
                }
                <span class="cov0" title="0">commandToRun = fmt.Sprintf("python3 kubenumerate.py -o %s", filePath)</span>
        default:<span class="cov0" title="0">
                // Case not registered, try and run it anyway see what could go wrong
                utils.ErrorMsg(fmt.Sprintf("Tool %s not supported", tool))</span>
        }

        // Run the tool
        <span class="cov0" title="0">toolOutput := fmt.Sprintf("%soutput.out", filePath)
        // Ensure path exists
        _, err := utils.CustomMkdir(filePath)
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Error creating custom dir %s: %v", filePath, err))
        }</span>

        <span class="cov0" title="0">cmd := strings.Split(commandToRun, " ")
        runCloudTool(cmd, toolOutput, OptVVerbose)

        return nil</span>
}

// runCloudTool is a new version of runTool for cloud - Announce cloud tool and run it
func runCloudTool(args []string, filePath string, OptVVerbose *bool) <span class="cov0" title="0">{
        tool := args[0]
        cmdArgs := args[1:]
        command := strings.Join(cmdArgs, " ")

        utils.PrintCustomBiColourMsg("magenta", "yellow", "[?] Debug -&gt; About to run ", tool, " against ", cmdArgs[0], " using the following command: ", strings.Join(args, " "))
        announceCloudTool(tool)

        cmd := exec.Command(tool, cmdArgs...)

        // Create a pipe to capture the command's output
        stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Error creating stdout pipe: %s", err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("failed to get stderr pipe: %v", err))
                return
        }</span>

        // Create a file to write the output to
        <span class="cov0" title="0">file, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Error creating output file: %s", err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">defer func(file *os.File) </span><span class="cov0" title="0">{
                err := file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        if *OptVVerbose </span><span class="cov0" title="0">{
                                utils.ErrorMsg(fmt.Sprintf("Error closing file: %s", err))
                        }</span>
                }
        }(file)

        // Start the command asynchronously in a goroutine
        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Error starting command %s: %v", tool, err))
                return
        }</span>

        // Use MultiWriter to copy stdout to both console and file simultaneously
        <span class="cov0" title="0">multiWriter := io.MultiWriter(os.Stdout, file)

        go func() </span><span class="cov0" title="0">{
                _, err := io.Copy(multiWriter, stdout)
                if err != nil </span><span class="cov0" title="0">{
                        if *OptVVerbose </span><span class="cov0" title="0">{
                                utils.ErrorMsg(fmt.Sprintf("Error copying stdout for tool %s: %v", tool, err))
                        }</span>
                }
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                _, err := io.Copy(os.Stderr, stderr)
                if err != nil </span><span class="cov0" title="0">{
                        if *OptVVerbose </span><span class="cov0" title="0">{
                                utils.ErrorMsg(fmt.Sprintf("Error copying stderr: %v", err))
                        }</span>
                }
        }()

        // Wait for the command to complete
        <span class="cov0" title="0">if err := cmd.Wait(); err != nil </span><span class="cov0" title="0">{
                if tool == "nikto" || tool == "fping" </span><span class="cov0" title="0">{
                        // Nikto and fping don't have a clean exit
                        utils.PrintCustomBiColourMsg("green", "cyan", "[+] Done! '", tool, "' finished successfully")
                        if filePath != "/dev/null" </span><span class="cov0" title="0">{
                                fmt.Println(utils.Yellow("\tShortcut: less -R"), utils.Cyan(filePath))
                        }</span>
                        <span class="cov0" title="0">return</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println(utils.Red("Command"), tool, utils.Red("finished with error:"), utils.Red(err))
                        return
                }</span>
        }

        <span class="cov0" title="0">printToolSuccess(command, tool, filePath)</span>
}

// RunCloudScan orchestrates the cloud security scanning
func RunCloudScan(cfg *config.CloudConfig) error <span class="cov0" title="0">{
        findings := make([]types.Finding, 0)

        for _, provider := range cfg.Providers </span><span class="cov0" title="0">{
                // Run tools concurrently if enabled
                if cfg.Concurrent </span><span class="cov0" title="0">{
                        results := make(chan types.ScanResult)
                        toolsLaunched := 0

                        if cfg.ScoutSuiteEnabled </span><span class="cov0" title="0">{
                                toolsLaunched++
                                go func() </span><span class="cov0" title="0">{
                                        result := runScoutSuite(provider, cfg)
                                        results &lt;- result
                                }</span>()
                        }

                        <span class="cov0" title="0">if cfg.ProwlerEnabled </span><span class="cov0" title="0">{
                                toolsLaunched++
                                go func() </span><span class="cov0" title="0">{
                                        result := runProwler(provider, cfg)
                                        results &lt;- result
                                }</span>()
                        }

                        // Collect results based on how many tools were actually launched
                        <span class="cov0" title="0">for i := 0; i &lt; toolsLaunched; i++ </span><span class="cov0" title="0">{
                                result := &lt;-results
                                if result.Error != nil </span><span class="cov0" title="0">{
                                        utils.ErrorMsg(fmt.Sprintf("Error running %s for %s: %v",
                                                result.Tool, result.Provider, result.Error))
                                        continue</span>
                                }
                                <span class="cov0" title="0">findings = append(findings, result.Findings...)</span>
                        }
                }
        }

        // Generate report
        <span class="cov0" title="0">return generateReport(findings, cfg)</span>
}

func runScoutSuite(provider string, cfg *config.CloudConfig) types.ScanResult <span class="cov0" title="0">{
        announceCloudTool("ScoutSuite")

        // Prepare output directory
        outputDir := fmt.Sprintf("%s/scoutsuite_%s", cfg.OutputPath, provider)
        if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                return types.ScanResult{
                        Provider: provider,
                        Tool:     "ScoutSuite",
                        Error:    fmt.Errorf("failed to create output directory: %v", err),
                }
        }</span>

        // Prepare command arguments
        <span class="cov0" title="0">args := []string{
                "scout",
                provider,
                "--format", "json",
                "--report-dir", outputDir,
                "--no-browser",
        }

        // Add provider-specific arguments
        switch provider </span>{
        case "aws":<span class="cov0" title="0">
                if cfg.AWSProfile != "" </span><span class="cov0" title="0">{
                        args = append(args, "--profile", cfg.AWSProfile)
                }</span>
        case "azure":<span class="cov0" title="0">
                if cfg.AzureSubscription != "" </span><span class="cov0" title="0">{
                        args = append(args, "--subscription", cfg.AzureSubscription)
                }</span>
        case "gcp":<span class="cov0" title="0">
                if cfg.GCPProject != "" </span><span class="cov0" title="0">{
                        args = append(args, "--project", cfg.GCPProject)
                }</span>
        }

        // Run ScoutSuite
        <span class="cov0" title="0">cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return types.ScanResult{
                        Provider:  provider,
                        Tool:      "ScoutSuite",
                        RawOutput: string(output),
                        Error:     fmt.Errorf("ScoutSuite failed: %v", err),
                }
        }</span>

        // Parse results
        <span class="cov0" title="0">findings, err := parseScoutSuiteResults(outputDir)
        if err != nil </span><span class="cov0" title="0">{
                return types.ScanResult{
                        Provider:  provider,
                        Tool:      "ScoutSuite",
                        RawOutput: string(output),
                        Error:     fmt.Errorf("failed to parse ScoutSuite results: %v", err),
                }
        }</span>

        <span class="cov0" title="0">return types.ScanResult{
                Provider:  provider,
                Tool:      "ScoutSuite",
                Findings:  findings,
                RawOutput: string(output),
        }</span>
}

func runProwler(provider string, cfg *config.CloudConfig) types.ScanResult <span class="cov0" title="0">{
        announceCloudTool("Prowler")

        // Prepare output directory
        outputDir := fmt.Sprintf("%s/prowler_%s", cfg.OutputPath, provider)
        if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                return types.ScanResult{
                        Provider: provider,
                        Tool:     "Prowler",
                        Error:    fmt.Errorf("failed to create output directory: %v", err),
                }
        }</span>

        // Prepare command arguments
        <span class="cov0" title="0">outputFile := fmt.Sprintf("%s/prowler_report.json", outputDir)
        args := []string{
                "prowler",
                provider,
                "-M", "json",
                "-o", outputFile,
                "--no-banner",
        }

        // Add provider-specific arguments
        switch provider </span>{
        case "aws":<span class="cov0" title="0">
                if cfg.AWSProfile != "" </span><span class="cov0" title="0">{
                        args = append(args, "-p", cfg.AWSProfile)
                }</span>
        case "azure":<span class="cov0" title="0">
                if cfg.AzureSubscription != "" </span><span class="cov0" title="0">{
                        args = append(args, "-s", cfg.AzureSubscription)
                }</span>
        case "gcp":<span class="cov0" title="0">
                if cfg.GCPProject != "" </span><span class="cov0" title="0">{
                        args = append(args, "-P", cfg.GCPProject)
                }</span>
        }

        // Run Prowler
        <span class="cov0" title="0">cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return types.ScanResult{
                        Provider:  provider,
                        Tool:      "Prowler",
                        RawOutput: string(output),
                        Error:     fmt.Errorf("prowler failed: %v", err),
                }
        }</span>

        // Parse results
        <span class="cov0" title="0">findings, err := parseProwlerResults(outputFile)
        if err != nil </span><span class="cov0" title="0">{
                return types.ScanResult{
                        Provider:  provider,
                        Tool:      "Prowler",
                        RawOutput: string(output),
                        Error:     fmt.Errorf("failed to parse Prowler results: %v", err),
                }
        }</span>

        <span class="cov0" title="0">return types.ScanResult{
                Provider:  provider,
                Tool:      "Prowler",
                Findings:  findings,
                RawOutput: string(output),
        }</span>
}

func parseScoutSuiteResults(outputDir string) ([]types.Finding, error) <span class="cov0" title="0">{
        // Read ScoutSuite's JSON report
        reportFile := filepath.Join(outputDir, "scoutsuite-report", "report.json")
        data, err := os.ReadFile(reportFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read ScoutSuite report: %v", err)
        }</span>

        // Parse JSON
        <span class="cov0" title="0">var report struct {
                Findings map[string]map[string]interface{} `json:"findings"`
        }
        if err := json.Unmarshal(data, &amp;report); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse ScoutSuite JSON: %v", err)
        }</span>

        // Convert to our Finding type
        <span class="cov0" title="0">var findings []types.Finding
        for service, serviceFindings := range report.Findings </span><span class="cov0" title="0">{
                for id, data := range serviceFindings </span><span class="cov0" title="0">{
                        finding := types.Finding{
                                ID:          id,
                                Service:     service,
                                Tool:        "ScoutSuite",
                                Severity:    mapScoutSuiteSeverity(data),
                                Resource:    getStringValue(data, "resource"),
                                Description: getStringValue(data, "description"),
                                Remediation: getStringValue(data, "remediation"),
                                RawData:     data,
                        }
                        findings = append(findings, finding)
                }</span>
        }

        <span class="cov0" title="0">return findings, nil</span>
}

func parseProwlerResults(filePath string) ([]types.Finding, error) <span class="cov0" title="0">{
        // Read Prowler's JSON report
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read Prowler report: %v", err)
        }</span>

        // Parse JSON
        <span class="cov0" title="0">var prowlerFindings []struct {
                Status      string `json:"Status"`
                ServiceName string `json:"ServiceName"`
                ResourceID  string `json:"ResourceId"`
                Message     string `json:"Message"`
                Severity    string `json:"Severity"`
                Risk        string `json:"Risk"`
                Remediation string `json:"Remediation"`
        }
        if err := json.Unmarshal(data, &amp;prowlerFindings); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse Prowler JSON: %v", err)
        }</span>

        // Convert to our Finding type
        <span class="cov0" title="0">var findings []types.Finding
        for _, pf := range prowlerFindings </span><span class="cov0" title="0">{
                finding := types.Finding{
                        Service:     pf.ServiceName,
                        Tool:        "Prowler",
                        Severity:    mapProwlerSeverity(pf.Severity),
                        Resource:    pf.ResourceID,
                        Description: pf.Message,
                        Remediation: pf.Remediation,
                        RawData:     pf,
                }
                findings = append(findings, finding)
        }</span>

        <span class="cov0" title="0">return findings, nil</span>
}

func mapScoutSuiteSeverity(data interface{}) types.Severity <span class="cov0" title="0">{
        if m, ok := data.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if level, ok := m["level"].(string); ok </span><span class="cov0" title="0">{
                        switch strings.ToLower(level) </span>{
                        case "critical":<span class="cov0" title="0">
                                return types.Critical</span>
                        case "high":<span class="cov0" title="0">
                                return types.High</span>
                        case "medium":<span class="cov0" title="0">
                                return types.Medium</span>
                        case "low":<span class="cov0" title="0">
                                return types.Low</span>
                        }
                }
        }
        <span class="cov0" title="0">return types.Info</span>
}

func mapProwlerSeverity(severity string) types.Severity <span class="cov0" title="0">{
        switch strings.ToUpper(severity) </span>{
        case "CRITICAL":<span class="cov0" title="0">
                return types.Critical</span>
        case "HIGH":<span class="cov0" title="0">
                return types.High</span>
        case "MEDIUM":<span class="cov0" title="0">
                return types.Medium</span>
        case "LOW":<span class="cov0" title="0">
                return types.Low</span>
        default:<span class="cov0" title="0">
                return types.Info</span>
        }
}

func getStringValue(data interface{}, key string) string <span class="cov0" title="0">{
        if m, ok := data.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if val, ok := m[key].(string); ok </span><span class="cov0" title="0">{
                        return val
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func generateReport(findings []types.Finding, cfg *config.CloudConfig) error <span class="cov0" title="0">{
        f := excelize.NewFile()
        defer func() </span><span class="cov0" title="0">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        utils.ErrorMsg(fmt.Sprintf("Error closing Excel file: %v", err))
                }</span>
        }()

        // Remove default Sheet1
        <span class="cov0" title="0">f.DeleteSheet("Sheet1")

        // Sort findings by provider and severity
        sort.Slice(findings, func(i, j int) bool </span><span class="cov0" title="0">{
                if findings[i].Provider != findings[j].Provider </span><span class="cov0" title="0">{
                        return findings[i].Provider &lt; findings[j].Provider
                }</span>
                <span class="cov0" title="0">return string(findings[i].Severity) &lt; string(findings[j].Severity)</span>
        })

        // Group findings by provider
        <span class="cov0" title="0">providerFindings := make(map[string][]types.Finding)
        for _, finding := range findings </span><span class="cov0" title="0">{
                providerFindings[finding.Provider] = append(providerFindings[finding.Provider], finding)
        }</span>

        // Create summary sheet
        <span class="cov0" title="0">createSummarySheet(f, providerFindings)

        // Create provider-specific sheets
        for provider, findings := range providerFindings </span><span class="cov0" title="0">{
                createProviderSheet(f, provider, findings)
        }</span>

        // Generate output filename with timestamp
        <span class="cov0" title="0">timestamp := time.Now().Format("20060102_150405")
        outputPath := fmt.Sprintf("%s/cloud_security_scan_%s.xlsx", cfg.OutputPath, timestamp)

        // Save the Excel file
        if err := f.SaveAs(outputPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error saving Excel file: %v", err)
        }</span>

        <span class="cov0" title="0">utils.PrintCustomBiColourMsg("green", "cyan", "[+] Report generated successfully: ", outputPath)
        return nil</span>
}

func createSummarySheet(f *excelize.File, providerFindings map[string][]types.Finding) <span class="cov0" title="0">{
        sheetName := "Summary"
        f.NewSheet(sheetName)

        // Set headers
        headers := []string{"Provider", "Critical", "High", "Medium", "Low", "Info", "Total"}
        for i, header := range headers </span><span class="cov0" title="0">{
                cell := fmt.Sprintf("%c1", 'A'+i)
                f.SetCellValue(sheetName, cell, header)
        }</span>

        // Add provider summaries
        <span class="cov0" title="0">row := 2
        for provider, findings := range providerFindings </span><span class="cov0" title="0">{
                severityCounts := countSeverities(findings)
                total := len(findings)

                f.SetCellValue(sheetName, fmt.Sprintf("A%d", row), provider)
                f.SetCellValue(sheetName, fmt.Sprintf("B%d", row), severityCounts[types.Critical])
                f.SetCellValue(sheetName, fmt.Sprintf("C%d", row), severityCounts[types.High])
                f.SetCellValue(sheetName, fmt.Sprintf("D%d", row), severityCounts[types.Medium])
                f.SetCellValue(sheetName, fmt.Sprintf("E%d", row), severityCounts[types.Low])
                f.SetCellValue(sheetName, fmt.Sprintf("F%d", row), severityCounts[types.Info])
                f.SetCellValue(sheetName, fmt.Sprintf("G%d", row), total)
                row++
        }</span>
}

func createProviderSheet(f *excelize.File, provider string, findings []types.Finding) <span class="cov0" title="0">{
        f.NewSheet(provider)

        // Set headers
        headers := []string{"Severity", "Service", "Resource", "Description", "Remediation"}
        for i, header := range headers </span><span class="cov0" title="0">{
                cell := fmt.Sprintf("%c1", 'A'+i)
                f.SetCellValue(provider, cell, header)
        }</span>

        // Add findings
        <span class="cov0" title="0">for i, finding := range findings </span><span class="cov0" title="0">{
                row := i + 2
                f.SetCellValue(provider, fmt.Sprintf("A%d", row), finding.Severity)
                f.SetCellValue(provider, fmt.Sprintf("B%d", row), finding.Service)
                f.SetCellValue(provider, fmt.Sprintf("C%d", row), finding.Resource)
                f.SetCellValue(provider, fmt.Sprintf("D%d", row), finding.Description)
                f.SetCellValue(provider, fmt.Sprintf("E%d", row), finding.Remediation)
        }</span>
}

func countSeverities(findings []types.Finding) map[types.Severity]int <span class="cov0" title="0">{
        counts := make(map[types.Severity]int)
        for _, finding := range findings </span><span class="cov0" title="0">{
                counts[finding.Severity]++
        }</span>
        <span class="cov0" title="0">return counts</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

type CloudConfig struct {
        // Tool settings
        PMMapperEnabled   bool
        ScoutSuiteEnabled bool
        ProwlerEnabled    bool
        CloudFoxEnabled   bool

        // Output settings
        OutputPath   string
        ReportFormat string // "xlsx", "json", etc.

        // Provider settings
        Providers         []string
        AWSProfile        string
        AzureSubscription string
        GCPProject        string

        // Runtime settings
        Concurrent     bool
        InstallMissing bool
        Verbose        bool
}

func NewCloudConfig() *CloudConfig <span class="cov0" title="0">{
        return &amp;CloudConfig{
                PMMapperEnabled:   true,
                ScoutSuiteEnabled: true,
                ProwlerEnabled:    true,
                CloudFoxEnabled:   true,
                ReportFormat:      "xlsx",
                Concurrent:        true,
                InstallMissing:    true,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package infra

import (
        "fmt"
        "net"
        "os"

        "github.com/0x5ubt13/enumeraga/internal/utils"
        "github.com/pborman/getopt/v2"
)

func Run(OptHelp, OptInstall, OptNmapOnly, OptQuiet, OptVVerbose *bool, OptOutput, OptTarget *string) int <span class="cov0" title="0">{
        // Parse optional infra arguments, getting rid of the 'infra' arg
        os.Args = os.Args[1:]
        getopt.Parse()

        // Check 0: banner!
        if !*OptQuiet </span><span class="cov0" title="0">{
                utils.PrintBanner()
        }</span>

        <span class="cov0" title="0">if !*OptQuiet </span><span class="cov0" title="0">{
                fmt.Printf("\n%s%s%s\n", utils.Cyan("[*] ---------- "), utils.Green("Starting infra checks phase"), utils.Cyan(" ----------"))
        }</span>

        // Check 1: Args passed fine?
        <span class="cov0" title="0">if len(os.Args) == 1 </span><span class="cov0" title="0">{
                utils.ErrorMsg("No arguments were provided.")
                printInfraUsage()
                utils.PrintInfraUsageExamples()
                os.Exit(1)
        }</span>

        // Check 2: Help flag or nmap flag passed?
        <span class="cov0" title="0">if *OptHelp </span><span class="cov0" title="0">{
                if !*OptQuiet </span><span class="cov0" title="0">{
                        fmt.Println(utils.Cyan("[*] Help flag detected. Aborting other checks and printing usage.\n"))
                }</span>
                <span class="cov0" title="0">printInfraUsage()
                utils.PrintInfraUsageExamples()
                os.Exit(0)</span>
        }

        <span class="cov0" title="0">if *OptNmapOnly </span><span class="cov0" title="0">{
                if !*OptQuiet </span><span class="cov0" title="0">{
                        fmt.Println(utils.Cyan("[*] Nmap only flag detected. Aborting other functionality of Enumeraga and only launching nmap scans.\n"))
                }</span>
        }

        // Check 3: I AM GROOT!!!!
        <span class="cov0" title="0">utils.CheckAdminPrivileges("infra")

        // Check 4: key tools exist in the system
        if !*OptQuiet &amp;&amp; !*OptNmapOnly </span><span class="cov0" title="0">{
                fmt.Println(utils.Cyan("[*] Checking all tools are installed... "))
        }</span>

        <span class="cov0" title="0">if !*OptNmapOnly </span><span class="cov0" title="0">{
                utils.InstallMissingTools('i', OptInstall)
        }</span>

        <span class="cov0" title="0">if *OptInstall &amp;&amp; !*OptNmapOnly </span><span class="cov0" title="0">{
                fmt.Println(utils.Green("[+] All pre-required tools have been installed! You're good to go! Run your first scan with enumeraga infra -t!"))
                os.Exit(0)
        }</span>

        // Call check 5
        <span class="cov0" title="0">checkFive(OptTarget)

        // Call check 6
        checkSix(OptOutput, OptQuiet, OptVVerbose)

        // Check 8: Determine whether it is a single target or multi-target and return number of lines
        return checkSeven(OptTarget)</span>

        // End of checks
}

// printInfraUsage prints only the infra-relevant flags, not cloud flags
func printInfraUsage() <span class="cov1" title="1">{
        fmt.Println("Usage: enumeraga infra [OPTIONS]")
        fmt.Println("\nOptions:")
        fmt.Println("  -b, --brute          Activate all fuzzing and bruteforce in the tool")
        fmt.Println("  -h, --help           Display this help and exit")
        fmt.Println("  -i, --install        Only try to install pre-requisite tools and exit")
        fmt.Println("  -n, --nmap-only      Activate nmap scans only and ignore all other tools")
        fmt.Println("  -o, --output DIR     Select a different base folder for output (default: /tmp/enumeraga_output)")
        fmt.Println("  -p, --top-ports N    Run port sweep with nmap --top-ports=N")
        fmt.Println("  -q, --quiet          Don't print the banner and decrease overall verbosity")
        fmt.Println("  -r, --range CIDR     Specify a CIDR range to use tools for whole subnets")
        fmt.Println("  -t, --target TARGET  Specify target single IP / List of IPs file (required)")
        fmt.Println("  -V, --vv             Flood your terminal with plenty of verbosity!")
        fmt.Println()
}</span>

// checkFive ensures there's a valid target
func checkFive(OptTarget *string) <span class="cov1" title="1">{
        if *OptTarget == "" </span><span class="cov0" title="0">{
                utils.ErrorMsg("You must provide an IP address or targets file with the flag -t to start the attack.")
                os.Exit(1)
        }</span>
}

// checkSix ensures base output directory is correctly set and exists
func checkSix(OptOutput *string, OptQuiet, OptVVerbose *bool) <span class="cov5" title="2">{
        _, err := utils.CustomMkdir(*OptOutput)
        if err != nil </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        utils.ErrorMsg(err)
                }</span>
        } else<span class="cov5" title="2"> {
                utils.PrintCustomBiColourMsg("green", "yellow", "[+] Directory ", *OptOutput, " created successfully")
        }</span>
        <span class="cov5" title="2">if !*OptQuiet </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("green", "yellow", "[+] Using '", *OptOutput, "' as base directory to save the ", "output ", "files")
        }</span>
}

// checkSeven finishes this section by returning number of lines if multi-target or 0 if single-target
func checkSeven(OptTarget *string) int <span class="cov10" title="4">{
        targetInput := net.ParseIP(*OptTarget)

        // Check if it's a valid IP address (IPv4 or IPv6)
        if targetInput != nil </span><span class="cov5" title="2">{
                // Valid IP - single target mode
                return 0
        }</span>

        // Not a valid IP - try to resolve as hostname/URL
        <span class="cov5" title="2">resolvedIP, err := utils.ResolveHostToIP(*OptTarget)
        if err == nil </span><span class="cov1" title="1">{
                // Successfully resolved hostname to IP
                utils.PrintCustomBiColourMsg("green", "cyan", "[+] Resolved hostname '", *OptTarget, "' to IP: ", resolvedIP)
                // Update OptTarget to use the resolved IP for scanning
                *OptTarget = resolvedIP
                return 0
        }</span>

        // Not a valid IP or hostname - assume it's a targets file
        // Validate file exists before attempting to read
        <span class="cov1" title="1">if err := utils.ValidateFilePath(*OptTarget); err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Target validation failed: %v", err))
                os.Exit(1)
        }</span>

        // Multi-target. Check file exists and get lines
        <span class="cov1" title="1">_, totalLines := utils.ReadTargetsFile(OptTarget)
        return totalLines</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package portsIterator

import (
        "fmt"
        "github.com/0x5ubt13/enumeraga/internal/checks"
        "os/exec"
        "strings"

        "github.com/0x5ubt13/enumeraga/internal/commands"
        "github.com/0x5ubt13/enumeraga/internal/utils"
)

// Enumerate File Transfer Protocol (20-21/TCP)
func ftp() <span class="cov0" title="0">{
        if utils.VisitedFTP </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">utils.VisitedFTP = true

        ftpDir := utils.ProtocolDetected("FTP", utils.BaseDir)
        commands.CallIndividualPortScannerWithNSEScripts(utils.Target, "20,21", ftpDir+"ftp_scan", "ftp-* and not brute", checks.OptVVerbose)

        // Hydra for FTP
        if *checks.OptBrute </span><span class="cov0" title="0">{
                hydraArgs := []string{"hydra", "-L", utils.UsersList, "-P", utils.DarkwebTop1000, "-f", fmt.Sprintf("%s://%s", "ftp", utils.Target)}
                hydraPath := fmt.Sprintf("%shydra_ftp.out", ftpDir)
                commands.CallRunTool(hydraArgs, hydraPath, checks.OptVVerbose)
        }</span>
}

// Enumerate Secure Shell Protocol (22/TCP)
func ssh() <span class="cov0" title="0">{
        sshDir := utils.ProtocolDetected("SSH", utils.BaseDir)
        commands.CallIndividualPortScannerWithNSEScripts(utils.Target, "22", sshDir+"ssh_scan", "ssh-* and not brute", checks.OptVVerbose)

        // Hydra for SSH
        if *checks.OptBrute </span><span class="cov0" title="0">{
                hydraArgs := []string{"hydra", "-L", utils.UsersList, "-P", utils.DarkwebTop1000, "-f", fmt.Sprintf("%s://%s", "ssh", utils.Target)}
                hydraPath := fmt.Sprintf("%shydra_ssh.out", sshDir)
                commands.CallRunTool(hydraArgs, hydraPath, checks.OptVVerbose)
        }</span>
}

// Enumerate Simple Mail Transfer Protocol (25,465,587/TCP)
func smtp() <span class="cov0" title="0">{
        if utils.VisitedSMTP </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">utils.VisitedSMTP = true

        smtpDir := utils.ProtocolDetected("SMTP", utils.BaseDir)
        commands.CallIndividualPortScannerWithNSEScripts(utils.Target, "25,465,587", smtpDir+"smtp_scan", "smtp-commands,smtp-enum-users,smtp-open-relay", checks.OptVVerbose)</span>
}

// Enumerate Domain Name System (53/TCP)
func dns() <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("DNS", utils.BaseDir)
        commands.CallIndividualPortScannerWithNSEScripts(utils.Target, "53", dir+"dns_scan", "*dns*", checks.OptVVerbose)
}</span>

// Enumerate Finger (79/TCP)
func finger() <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("Finger", utils.BaseDir)
        nmapOutputFile := dir + "finger_scan"
        commands.CallIndividualPortScanner(utils.Target, "79", nmapOutputFile, checks.OptVVerbose)

        msfArgs := []string{"msfconsole", "-q", "-x", fmt.Sprintf("use auxiliary/scanner/finger/finger_users;set rhost %s;run;exit", utils.Target)}
        msfPath := fmt.Sprintf("%smsfconsole.out", dir)
        commands.CallRunTool(msfArgs, msfPath, checks.OptVVerbose)
}</span>

// Enumerate HyperText Transfer Protocol (80,443,8080/TCP)
func http() <span class="cov0" title="0">{
        if utils.VisitedHTTP </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">utils.VisitedHTTP = true

        dir := utils.ProtocolDetected("HTTP", utils.BaseDir)
        commands.CallIndividualPortScanner(utils.Target, "80,443,8080", dir+"http_scan", checks.OptVVerbose)

        // Port 80:
        // WordPress on port 80
        commands.CallWPEnumeration(fmt.Sprintf("http://%s:80", utils.Target), dir, "80", checks.OptVVerbose)

        // Nikto on port 80
        nikto80Args := []string{"nikto", "-host", fmt.Sprintf("http://%s:80", utils.Target)}
        nikto80Path := fmt.Sprintf("%snikto_80.out", dir)
        commands.CallRunTool(nikto80Args, nikto80Path, checks.OptVVerbose)

        // Wafw00f on port 80
        wafw00f80Args := []string{"wafw00f", "-v", fmt.Sprintf("http://%s:80", utils.Target)}
        wafw00f80Path := fmt.Sprintf("%swafw00f_80.out", dir)
        commands.CallRunTool(wafw00f80Args, wafw00f80Path, checks.OptVVerbose)

        // WhatWeb on port 80
        whatWeb80Args := []string{"whatweb", "-a", "3", "-v", fmt.Sprintf("http://%s:80", utils.Target)}
        whatWeb80Path := fmt.Sprintf("%swhatweb_80.out", dir)
        commands.CallRunTool(whatWeb80Args, whatWeb80Path, checks.OptVVerbose)

        // Dirsearch - Light dirbusting on port 80
        dirsearch80Args := []string{"dirsearch", "-t", "10", "-q", "-u", fmt.Sprintf("http://%s:80", utils.Target)}
        dirsearch80Path := fmt.Sprintf("%sdirsearch_80.out", dir)
        commands.CallRunTool(dirsearch80Args, dirsearch80Path, checks.OptVVerbose)

        if *checks.OptBrute </span><span class="cov0" title="0">{
                // TODO: check why ffuf doesn't work
                // CeWL + Ffuf Keywords Bruteforcing
                commands.CallRunCewlandFfufKeywords(utils.Target, dir, "80", checks.OptVVerbose)
                commands.CallRunCewlandFfufKeywords(utils.Target, dir, "443", checks.OptVVerbose)
        }</span>

        // Port 443:

        // WordPress on port 443
        <span class="cov0" title="0">commands.CallWPEnumeration(fmt.Sprintf("https://%s:443", utils.Target), dir, "443", checks.OptVVerbose)

        // Nikto on port 443
        nikto443Args := []string{"nikto", "-host", fmt.Sprintf("https://%s:443", utils.Target)}
        nikto443Path := fmt.Sprintf("%snikto_443.out", dir)
        commands.CallRunTool(nikto443Args, nikto443Path, checks.OptVVerbose)

        // Wafw00f on port 443
        wafw00f443Args := []string{"wafw00f", "-v", fmt.Sprintf("https://%s:443", utils.Target)}
        wafw00f443Path := fmt.Sprintf("%swafw00f_443.out", dir)
        commands.CallRunTool(wafw00f443Args, wafw00f443Path, checks.OptVVerbose)

        // WhatWeb on port 443
        whatWeb443Args := []string{"whatweb", "-a", "3", "-v", fmt.Sprintf("http://%s:443", utils.Target)}
        whatWeb443Path := fmt.Sprintf("%swhatweb_443.out", dir)
        commands.CallRunTool(whatWeb443Args, whatWeb443Path, checks.OptVVerbose)

        // Dirsearch - Light dirbusting on port 443
        dirsearch443Args := []string{"dirsearch", "-t", "10", "-q", "-u", fmt.Sprintf("https://%s:443", utils.Target)}
        dirsearch443Path := fmt.Sprintf("%sdirsearch_443.out", dir)
        commands.CallRunTool(dirsearch443Args, dirsearch443Path, checks.OptVVerbose)

        // TestSSL on port 443
        testssl := "testssl"
        if !utils.CheckToolExists("testssl") </span><span class="cov0" title="0">{
                if utils.CheckToolExists("testssl.sh") </span><span class="cov0" title="0">{
                testssl = "testssl.sh"
                }</span>
        }

        <span class="cov0" title="0">testsslArgs := []string{testssl, fmt.Sprintf("https://%s:443", utils.Target)}
        testsslPath := fmt.Sprintf("%stestssl.out", dir)
        commands.CallRunTool(testsslArgs, testsslPath, checks.OptVVerbose)

        // Port 8080

        // WordPress on port 8080
        commands.CallWPEnumeration(fmt.Sprintf("http://%s:8080", utils.Target), dir, "8080", checks.OptVVerbose)

        // Tomcat
        commands.CallTomcatEnumeration(utils.Target, fmt.Sprintf("http://%s:8080/docs", utils.Target), dir, "8080", checks.OptBrute, checks.OptVVerbose)</span>
}

// Enumerate Kerberos Protocol (88/TCP)
func kerberos() <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("Kerberos", utils.BaseDir)
        nmapOutputFile := dir + "kerberos_scan"
        commands.CallIndividualPortScanner(utils.Target, "88", nmapOutputFile, checks.OptVVerbose)

        filePath := dir + "potential_DC_commands.txt"
        message := `
        Potential DC found. Enumerate further.
        Get the name of the domain and chuck it to:
        nmap -p 88 \ 
        --script=krb5-enum-users \
        --script-args krb5-enum-users.realm=\"{Domain_Name}\" \\\n,userdb={Big_Userlist} \\\n{IP}"`
        if err := utils.WriteTextToFile(filePath, message); err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Failed to write kerberos commands file: %v", err))
        }</span>
}

// Enumerate Internet Message Access Protocol (110,143,993,995/TCP)
func imap() <span class="cov0" title="0">{
        if utils.VisitedIMAP </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">utils.VisitedIMAP = true

        dir := utils.ProtocolDetected("IMAP-POP3", utils.BaseDir)
        nmapOutputFile := dir + "imap_pop3_scan"
        commands.CallIndividualPortScanner(utils.Target, "110,143,993,995", nmapOutputFile, checks.OptVVerbose)

        // Openssl
        openSSLArgs := []string{"openssl", "s_client", "-connect", fmt.Sprintf("%s:imaps", utils.Target)}
        openSSLPath := fmt.Sprintf("%sopenssl_imap.out", dir)
        commands.CallRunTool(openSSLArgs, openSSLPath, checks.OptVVerbose)

        // NC banner grabbing
        ports := []string{"110", "143", "993", "995"}
        for port := range ports </span><span class="cov0" title="0">{
                ncArgs := []string{"nc", "-nv", utils.Target, ports[port]}
                ncPath := fmt.Sprintf("%s%s_banner_grab.out", dir, ports[port])
                commands.CallRunTool(ncArgs, ncPath, checks.OptVVerbose)
        }</span>
}

// Enumerate Remote Procedure Call Protocol (111/TCP)
func rpc() <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("RPC", utils.BaseDir)
        nmapOutputFile := dir + "rpc_scan"
        commands.CallIndividualPortScanner(utils.Target, "111", nmapOutputFile, checks.OptVVerbose)
}</span>

// Enumerate Ident Protocol (113/TCP)
func ident(openPortsSlice []string) <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("Ident", utils.BaseDir)
        nmapOutputFile := dir + "ident_scan"
        commands.CallIndividualPortScanner(utils.Target, "113", nmapOutputFile, checks.OptVVerbose)

        // ident-user-enum
        spacedPorts := strings.Join(openPortsSlice, " ")
        identUserEnumArgs := []string{"ident-user-enum", utils.Target, spacedPorts}
        identUserEnumPath := fmt.Sprintf("%sident-user-enum.out", dir)
        commands.CallRunTool(identUserEnumArgs, identUserEnumPath, checks.OptVVerbose)
}</span>

// Enumerate Microsoft's Remote Procedure Call Protocol (135,593/TCP)
func msrpc() <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("MSRPC", utils.BaseDir)
        nmapOutputFile := dir + "msrpc_scan"
        commands.CallIndividualPortScanner(utils.Target, "135,593", nmapOutputFile, checks.OptVVerbose)

        rpcDump135Args := []string{"impacket-rpcdump", "135"}
        rpcDump135Path := fmt.Sprintf("%srpcdump_135.out", dir)
        commands.CallRunTool(rpcDump135Args, rpcDump135Path, checks.OptVVerbose)

        rpcDump593Args := []string{"impacket-rpcdump", "593"}
        rpcDump593Path := fmt.Sprintf("%srpcdump_593.out", dir)
        commands.CallRunTool(rpcDump593Args, rpcDump593Path, checks.OptVVerbose)
}</span>

// Enumerate NetBIOS / Server Message Block Protocol (137-139,445/TCP - 137/UDP)
func smb() <span class="cov0" title="0">{
        if utils.VisitedSMB </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">utils.VisitedSMB = true
        dir := utils.ProtocolDetected("NetBIOS-SMB", utils.BaseDir)

        // Nmap
        nmapOutputFile := dir + "nb_smb_scan"
        nmapUDPOutputFile := dir + "nb_smb_UDP_scan"
        nmapNSEScripts := "smb* and not brute"
        commands.CallIndividualPortScannerWithNSEScripts(utils.Target, "137,138,139,445", nmapOutputFile, nmapNSEScripts, checks.OptVVerbose) // TCP
        commands.CallIndividualUDPPortScannerWithNSEScripts(utils.Target, "137", nmapUDPOutputFile, "nbstat.nse", checks.OptVVerbose)         // UDP

        // CME
        cmeArgs := []string{"crackmapexec", "smb", "-u", "''", "-p", "''", utils.Target}
        cmePath := fmt.Sprintf("%scme_anon.out", dir)
        commands.CallRunTool(cmeArgs, cmePath, checks.OptVVerbose)

        if *checks.OptBrute </span><span class="cov0" title="0">{
                // CME BruteForcing
                cmeBfArgs := []string{"crackmapexec", "smb", "-u", utils.UsersList, "-p", utils.DarkwebTop1000, "--shares", "--sessions", "--disks", "--loggedon-users", "--users", "--groups", "--computers", "--local-groups", "--pass-pol", "--rid-brute", utils.Target}
                cmeBfPath := fmt.Sprintf("%scme_bf.out", dir)
                commands.CallRunTool(cmeBfArgs, cmeBfPath, checks.OptVVerbose)
        }</span>

        // SMBMap
        <span class="cov0" title="0">smbMapArgs := []string{"smbmap", "-H", utils.Target}
        smbMapPath := fmt.Sprintf("%ssmbmap.out", dir)
        commands.CallRunTool(smbMapArgs, smbMapPath, checks.OptVVerbose)

        // NMBLookup
        nmbLookupArgs := []string{"nmblookup", "-A", utils.Target}
        nmbLookupPath := fmt.Sprintf("%snmblookup.out", dir)
        commands.CallRunTool(nmbLookupArgs, nmbLookupPath, checks.OptVVerbose)

        // Enum4linux-ng
        enum4linuxNgArgs := []string{"enum4linux-ng", "-A", "-C", utils.Target}
        enum4linuxNgPath := fmt.Sprintf("%senum4linux_ng.out", dir)
        commands.CallRunTool(enum4linuxNgArgs, enum4linuxNgPath, checks.OptVVerbose)</span>
}

// Enumerate Simple Network Management Protocol (161-162,10161-10162/UDP)
func snmp() <span class="cov0" title="0">{
        // TODO: (outstanding from AutoEnum)
        // Hold on all SNMP enumeration until onesixtyone has finished bruteforcing community strings
        // then launch the tools in a loop against all the found CS
        if utils.VisitedSNMP </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">utils.VisitedSNMP = true
        dir := utils.ProtocolDetected("SNMP", utils.BaseDir)

        // Nmap
        nmapOutputFile := dir + "snmp_scan"
        nmapNSEScripts := "snmp* and not snmp-brute"
        commands.CallIndividualUDPPortScannerWithNSEScripts(utils.Target, "161,162,10161,10162", nmapOutputFile, nmapNSEScripts, checks.OptVVerbose)

        // SNMPWalk
        snmpWalkArgs := []string{"snmpwalk", "-v2c", "-c", "public", utils.Target}
        snmpWalkPath := fmt.Sprintf("%ssnmpwalk_v2c_public.out", dir)
        commands.CallRunTool(snmpWalkArgs, snmpWalkPath, checks.OptVVerbose)

        // OneSixtyOne
        oneSixtyOneArgs := []string{"onesixtyone", "-c", utils.SnmpList, utils.Target}
        oneSixtyOnePath := fmt.Sprintf("%snblookup.out", dir)
        commands.CallRunTool(oneSixtyOneArgs, oneSixtyOnePath, checks.OptVVerbose)

        // Braa
        // automate bf other CS than public
        braaArgs := []string{"braa", fmt.Sprintf("public@%s:.1.3.6.*", utils.Target)}
        braaPath := fmt.Sprintf("%sbraa_public.out", dir)
        commands.CallRunTool(braaArgs, braaPath, checks.OptVVerbose)</span>
}

// Enumerate Light Desktop Access Protocol (389,636,3268-3269/TCP)
func ldap() <span class="cov0" title="0">{
        if utils.VisitedLDAP </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">utils.VisitedLDAP = true
        dir := utils.ProtocolDetected("LDAP", utils.BaseDir)

        // Nmap
        nmapOutputFile := dir + "ldap_scan"
        nmapNSEScripts := "ldap* and not brute"
        commands.CallIndividualPortScannerWithNSEScripts(utils.Target, "389,636,3268,3269", nmapOutputFile, nmapNSEScripts, checks.OptVVerbose)

        // LDAPSearch - Anonymous bind to discover base DN
        ldapSearchArgs := []string{"ldapsearch", "-x", "-H", fmt.Sprintf("ldap://%s", utils.Target), "-s", "base", "-b", "", "defaultNamingContext"}
        ldapSearchPath := fmt.Sprintf("%sldapsearch_base_discovery.out", dir)
        commands.CallRunTool(ldapSearchArgs, ldapSearchPath, checks.OptVVerbose)

        // LDAPSearch - Anonymous bind to enumerate everything (if allowed)
        ldapSearchFullArgs := []string{"ldapsearch", "-x", "-H", fmt.Sprintf("ldap://%s", utils.Target), "-b", ""}
        ldapSearchFullPath := fmt.Sprintf("%sldapsearch_anonymous_dump.out", dir)
        commands.CallRunTool(ldapSearchFullArgs, ldapSearchFullPath, checks.OptVVerbose)

        // Create helper file with manual enumeration instructions
        filePath := dir + "ldap_manual_enum_tips.txt"
        message := fmt.Sprintf(`LDAP Enumeration Tips:

1. Check the base discovery output to find the base DN:
   less -R %sldapsearch_base_discovery.out

2. Once you have the base DN (e.g., DC=example,DC=com), run:
   ldapsearch -x -H ldap://%s -b "DC=example,DC=com"

3. Try common LDAP queries:
   # List all users
   ldapsearch -x -H ldap://%s -b "DC=example,DC=com" "(objectClass=user)"

   # List all groups
   ldapsearch -x -H ldap://%s -b "DC=example,DC=com" "(objectClass=group)"

   # List all computers
   ldapsearch -x -H ldap://%s -b "DC=example,DC=com" "(objectClass=computer)"

4. If anonymous bind fails, try authenticated bind:
   ldapsearch -x -H ldap://%s -D "CN=username,DC=example,DC=com" -w password -b "DC=example,DC=com"

5. For LDAPS (port 636), use:
   ldapsearch -x -H ldaps://%s -b "DC=example,DC=com"
`, ldapSearchPath, utils.Target, utils.Target, utils.Target, utils.Target, utils.Target, utils.Target)
        if err := utils.WriteTextToFile(filePath, message); err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Failed to write LDAP enumeration tips file: %v", err))
        }</span>
}

// Enumerate Berkeley R-services (512-514/TCP)
func rservices() <span class="cov0" title="0">{
        if utils.VisitedRsvc </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">utils.VisitedRsvc = true
        dir := utils.ProtocolDetected("RServices", utils.BaseDir)

        // Nmap
        nmapOutputFile := dir + "rservices_scan"
        commands.CallIndividualPortScanner(utils.Target, "512,513,514", nmapOutputFile, checks.OptVVerbose)

        // Rwho
        rwhoArgs := []string{"rwho", "-a", utils.Target}
        rwhoPath := fmt.Sprintf("%srwho.out", dir)
        commands.CallRunTool(rwhoArgs, rwhoPath, checks.OptVVerbose)

        // Rusers
        rusersArgs := []string{"rusers", "-la", utils.Target}
        rusersPath := fmt.Sprintf("%srusers.out", dir)
        commands.CallRunTool(rusersArgs, rusersPath, checks.OptVVerbose)

        filePath := dir + "next_step_tip.txt"
        message := `
        Tip: Enumerate NFS, etc on the utils.Target server for /home/user/.rhosts and /etc/hosts.equiv files to use with rlogin, rsh and rexec.
        If found, use the following command:
        rlogin "utils.Target" -l "found_user"`
        if err := utils.WriteTextToFile(filePath, message); err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Failed to write r-services enumeration tips file: %v", err))
        }</span>
}

// Enumerate Intelligent Platform Management Interface Protocol (623/TCP)
func ipmi() <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("IPMI", utils.BaseDir)
        nmapOutputFile := dir + "ipmi_scan"

        // Nmap
        nmapNSEScripts := "ipmi*"
        commands.CallIndividualUDPPortScannerWithNSEScripts(utils.Target, "623", nmapOutputFile, nmapNSEScripts, checks.OptVVerbose)

        // Metasploit
        msfArgs := []string{"msfconsole", "-q", "-x", fmt.Sprintf("use auxiliary/scanner/ipmi/ipmi_dumphashes; set rhosts %s; set output_john_file %sipmi_hashes.john; run; exit", utils.Target, dir)}
        msfPath := fmt.Sprintf("%smsf_scanner.out", dir)
        commands.CallRunTool(msfArgs, msfPath, checks.OptVVerbose)
}</span>

// Enumerate Remote Synchronisation protocol (873/TCP)
func rsync() <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("Rsync", utils.BaseDir)
        nmapOutputFile := dir + "rsync_scan"
        commands.CallIndividualPortScanner(utils.Target, "873", nmapOutputFile, checks.OptVVerbose)

        // Netcat
        ncArgs := []string{"nc", "-nv", utils.Target, "873"}
        ncPath := fmt.Sprintf("%sbanner_grab.out", dir)
        commands.CallRunTool(ncArgs, ncPath, checks.OptVVerbose)

        filePath := dir + "next_steps_tip.txt"
        message := `Tip: If nc's output has a drive in it after enumerating the version, for example 'dev', your natural following step should be:
        "rsync -av --list-only rsync://${utils.Target}/dev"`
        if err := utils.WriteTextToFile(filePath, message); err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Failed to write rsync enumeration tips file: %v", err))
        }</span>
}

// Enumerate Microsoft's SQL Server (1433/TCP)
func mssql() <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("MSSQL", utils.BaseDir)
        nmapOutputFile := dir + "mssql"
        nmapNSEScripts := "ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell,ms-sql-config,ms-sql-ntlm-info,ms-sql-tables,ms-sql-hasdbaccess,ms-sql-dac,ms-sql-dump-hashes"
        nmapNSEScriptsArgs := map[string]string{
                "mssql.instance-port": "1433",
                "mssql.username":      "sa",
                "mssql.password":      "",
                "mssql.instance-name": "MSSQLSERVER",
        }
        commands.CallIndividualPortScannerWithNSEScriptsAndScriptArgs(utils.Target, "1433", nmapOutputFile, nmapNSEScripts, nmapNSEScriptsArgs, checks.OptVVerbose)

        if *checks.OptBrute </span><span class="cov0" title="0">{
                bruteCMEArgs := []string{"crackmapexec", "mssql", utils.Target, "-u", utils.UsersList, "-p", utils.DarkwebTop1000}
                bruteCMEPath := fmt.Sprintf("%scme_brute.out", dir)
                commands.CallRunTool(bruteCMEArgs, bruteCMEPath, checks.OptVVerbose)
        }</span>
}

// Enumerate Oracle's Transparent Network Substrate (1521/TCP)
func tns() <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("TNS", utils.BaseDir)
        nmapOutputFile := dir + "tns_scan"
        nmapNSEScripts := "oracle-sid-brute"
        commands.CallIndividualPortScannerWithNSEScripts(utils.Target, "1521", nmapOutputFile, nmapNSEScripts, checks.OptVVerbose)

        // TODO: Check executing this: odat all -s "${1}" &gt;&gt; "${tns_dir}odat.out" &amp;&amp;
        startSentence := "[!] Run this manually: '"
        midSentence := fmt.Sprintf("odat all --output-file %sodat.out -s %s", dir, utils.Target)
        utils.PrintCustomBiColourMsg("yellow", "cyan", startSentence, midSentence, "'")
}</span>

// Enumerate Network File System Protocol (2049/TCP)
func nfs() <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("NFS/", utils.BaseDir)
        nmapOutputFile := dir + "nfs_scan"
        nmapNSEScripts := "nfs-ls,nfs-showmount,nfs-statfs"
        commands.CallIndividualPortScannerWithNSEScripts(utils.Target, "2049", nmapOutputFile, nmapNSEScripts, checks.OptVVerbose)

        // Showmount and mount
        showmountArgs := []string{"showmount", "-e", utils.Target}
        showmountPath := fmt.Sprintf("%sshowmount.out", dir)
        commands.CallRunTool(showmountArgs, showmountPath, checks.OptVVerbose)

        // Mkdir and mount, to mount every found drive with showmount
        mountDir := fmt.Sprintf("%s%s", dir, "mounted_NFS_contents/")
        _, err := utils.CustomMkdir(mountDir)
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Error creating dir: %v", err))
        }</span>

        <span class="cov0" title="0">showmountOut, err := exec.Command("bash", "-c", fmt.Sprintf("cat %sshowmount.out", dir)).Output()
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Error reading showmount output: %v. NFS enumeration may be incomplete.", err))
                return
        }</span>
        <span class="cov0" title="0">dirsToMount := []string{}
        for _, line := range strings.Split(string(showmountOut), "\n") </span><span class="cov0" title="0">{
                if strings.Contains(line, "/") </span><span class="cov0" title="0">{
                        dirsToMount = append(dirsToMount, strings.Split(line, " ")[0])
                }</span>
        }

        <span class="cov0" title="0">if len(dirsToMount) == 0 </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("yellow", "cyan", "[!] No NFS shares found to mount on target '", utils.Target, "'")
                return
        }</span>

        <span class="cov0" title="0">mountedDirs := []string{}
        for _, dirToMount := range dirsToMount </span><span class="cov0" title="0">{
                localMountPath := fmt.Sprintf("%s%s/", mountDir, strings.ReplaceAll(dirToMount, "/", "_"))
                _, err := utils.CustomMkdir(localMountPath)
                if err != nil </span><span class="cov0" title="0">{
                        utils.ErrorMsg(fmt.Sprintf("Error creating dir for NFS mount: %v", err))
                        continue</span>
                }
                <span class="cov0" title="0">mountCmd := exec.Command("bash", "-c", fmt.Sprintf("mount -t nfs %s:%s %s -o nolock,vers=3,tcp,timeo=300", utils.Target, dirToMount, localMountPath))
                if err := mountCmd.Run(); err != nil </span><span class="cov0" title="0">{
                        utils.ErrorMsg(fmt.Sprintf("Error mounting NFS share %s: %v. Continuing with other shares...", dirToMount, err))
                        continue</span>
                }
                <span class="cov0" title="0">mountedDirs = append(mountedDirs, localMountPath)
                utils.PrintCustomBiColourMsg("green", "cyan", "[+] Successfully mounted NFS share '", dirToMount, "' to '", localMountPath, "'")</span>
        }

        <span class="cov0" title="0">if len(mountedDirs) == 0 </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("yellow", "cyan", "[!] No NFS shares could be mounted on target '", utils.Target, "'")
                return
        }</span>

        <span class="cov0" title="0">treeCmd := exec.Command("bash", "-c", fmt.Sprintf("tree %s &gt;&gt; %snfs_mounts.tree 2&gt;&amp;1", mountDir, mountDir))
        if err := treeCmd.Run(); err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Error running tree command: %v. Skipping tree output.", err))
        }</span>

        <span class="cov0" title="0">if err := utils.WriteTextToFile(fmt.Sprintf("%scleanup_readme.txt", mountDir), fmt.Sprintf("To clean up and unmount the NFS drive, run 'umount -v '%s'/(mounted dirs)\n", mountDir)); err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("Failed to write NFS cleanup readme: %v", err))
        }</span>
}

// Enumerate MySQL server (3306/TCP)
func mysql() <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("MYSQL", utils.BaseDir)
        nmapOutputFile := dir + "mysql_scan"
        nmapNSEScripts := "mysql*"
        commands.CallIndividualPortScannerWithNSEScripts(utils.Target, "3306", nmapOutputFile, nmapNSEScripts, checks.OptVVerbose)

        // Hydra for MySQL
        if *checks.OptBrute </span><span class="cov0" title="0">{
                hydraArgs := []string{"hydra", "-L", utils.UsersList, "-P", utils.DarkwebTop1000, "-f", fmt.Sprintf("%s://%s", "mysql", utils.Target)}
                hydraPath := fmt.Sprintf("%shydra_mysql.out", dir)
                commands.CallRunTool(hydraArgs, hydraPath, checks.OptVVerbose)
        }</span>
}

// Enumerate Remote Desktop Protocol (3389/TCP)
func rdp() <span class="cov0" title="0">{
        dir := utils.ProtocolDetected("RDP", utils.BaseDir)
        nmapOutputFile := dir + "rdp_scan"
        nmapNSEScripts := "rdp*"
        commands.CallIndividualPortScannerWithNSEScripts(utils.Target, "3389", nmapOutputFile, nmapNSEScripts, checks.OptVVerbose)

        // Hydra for RDP
        if *checks.OptBrute </span><span class="cov0" title="0">{
                hydraArgs := []string{"hydra", "-L", utils.UsersList, "-P", utils.DarkwebTop1000, "-f", fmt.Sprintf("%s://%s", "rdp", utils.Target)}
                hydraPath := fmt.Sprintf("%shydra_rdp.out", dir)
                commands.CallRunTool(hydraArgs, hydraPath, checks.OptVVerbose)
        }</span>
}

// Enumerate Windows Remote Management Protocol (5985-5968/TCP)
func winrm() <span class="cov0" title="0">{
        if utils.VisitedWinRM </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">utils.VisitedWinRM = true

        dir := utils.ProtocolDetected("WinRM", utils.BaseDir)
        nmapOutputFile := dir + "winrm_scan"
        commands.CallIndividualPortScanner(utils.Target, "5985,5986", nmapOutputFile, checks.OptVVerbose)</span>
}

// Enumerate Webmin (10000/TCP)
func tenthousand() <span class="cov0" title="0">{
        // TODO: if not webmin, enum ndmp.
        dir := utils.ProtocolDetected("webmin", utils.BaseDir)
        nmapOutputFile := dir + "webmin_scan"
        commands.CallIndividualPortScanner(utils.Target, "10000", nmapOutputFile, checks.OptVVerbose)
}</span>

// Iterate through each port, group up by protocol and automate launching tools
func Run(openPortsSlice []string) <span class="cov0" title="0">{
        for _, port := range openPortsSlice </span><span class="cov0" title="0">{
                switch port </span>{
                case "20", "21", "22", "25", "465", "587", "53", "79", "80", "443", "8080", "88", "110", "143", "993", "995", "111", "113", "135", "593", "137", "138", "139", "445":<span class="cov0" title="0">
                        upToSMB(port, openPortsSlice)</span>

                case "161", "162", "10161", "10162", "389", "636", "3268", "3269", "512", "513", "514", "623", "873", "1433", "1521", "2049", "3306", "3389", "5985", "5986", "10000":<span class="cov0" title="0">
                        beyondSMB(port)</span>

                default:<span class="cov0" title="0">
                        if *checks.OptVVerbose </span><span class="cov0" title="0">{
                                fmt.Printf("%s %s %s %s %s\n", utils.Red("[-] Port"), utils.Yellow(port), utils.Red("detected, but I don't know how to handle it yet. Please check the"), utils.Cyan("main Nmap"), utils.Red("scan"))
                        }</span>
                }
        }
}

// Splitting Run in half for maintainability purposes
func upToSMB(port string, openPortsSlice []string) <span class="cov0" title="0">{
        switch port </span>{
        case "20", "21":<span class="cov0" title="0">
                ftp()</span>
        case "22":<span class="cov0" title="0">
                ssh()</span>
        case "25", "465", "587":<span class="cov0" title="0">
                smtp()</span>
        case "53":<span class="cov0" title="0">
                dns()</span>
        case "79":<span class="cov0" title="0">
                finger()</span>
        case "80", "443", "8080":<span class="cov0" title="0">
                http()</span>
        case "88":<span class="cov0" title="0">
                kerberos()</span>
        case "110", "143", "993", "995":<span class="cov0" title="0">
                imap()</span>
        case "111":<span class="cov0" title="0">
                rpc()</span>
        case "113":<span class="cov0" title="0">
                ident(openPortsSlice)</span>
        case "135", "593":<span class="cov0" title="0">
                msrpc()</span>
        case "137", "138", "139", "445":<span class="cov0" title="0">
                smb()</span>
        }
}

// Splitting Run in half for maintainability purposes
func beyondSMB(port string) <span class="cov0" title="0">{
        switch port </span>{
        case "161", "162", "10161", "10162":<span class="cov0" title="0"> // UDP
                snmp()</span>
        case "389", "636", "3268", "3269":<span class="cov0" title="0">
                ldap()</span>
        case "512", "513", "514":<span class="cov0" title="0">
                rservices()</span>
        case "623":<span class="cov0" title="0">
                ipmi()</span>
        case "873":<span class="cov0" title="0">
                rsync()</span>
        case "1433":<span class="cov0" title="0">
                mssql()</span>
        case "1521":<span class="cov0" title="0">
                tns()</span>
        case "2049":<span class="cov0" title="0">
                nfs()</span>
        case "3306":<span class="cov0" title="0">
                mysql()</span>
        case "3389":<span class="cov0" title="0">
                rdp()</span>
        case "5985", "5986":<span class="cov0" title="0">
                winrm()</span>
        case "10000":<span class="cov0" title="0">
                tenthousand()</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package scans

import (
        "context"
        "fmt"
        "log"
        "strconv"
        "sync"
        "time"

        "github.com/0x5ubt13/enumeraga/internal/utils"
        "github.com/Ullaakut/nmap/v3"
)

// TcpPortSweep runs a quick port sweep on TCP.
func TcpPortSweep(target string, OptVVerbose *bool) []nmap.Host <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
        defer cancel()

        // Equivalent to `/usr/local/bin/nmap -p1-65535 --min-rate=2000 --privileged &lt;target&gt;`,
        // with a 15-minute timeout.
        scanner, err := nmap.NewScanner(
                ctx,
                nmap.WithTargets(target),
                nmap.WithPorts("1-65535"),
                nmap.WithMinRate(2000),
                nmap.WithPrivileged(),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to create nmap scanner: %v", err)
        }</span>

        <span class="cov0" title="0">result, warnings, err := scanner.Run()
        if len(*warnings) &gt; 0 </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        fmt.Printf("run finished with warnings: %s\n", *warnings)
                }</span> // Warnings are non-critical errors from nmap.
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to run nmap scan: %v", err)
        }</span>

        <span class="cov0" title="0">utils.TimesSwept += 1

        return result.Hosts</span>
}

func SlowerTcpPortSweep(target string, OptVVerbose *bool) []nmap.Host <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
        defer cancel()

        // Equivalent to `/usr/local/bin/nmap -p1-65535 --min-rate=2000 --privileged &lt;target&gt;`,
        // with a 15-minute timeout.
        scanner, err := nmap.NewScanner(
                ctx,
                nmap.WithTargets(target),
                nmap.WithPorts("1-65535"),
                nmap.WithMinRate(500),
                nmap.WithPrivileged(),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to create nmap scanner: %v", err)
        }</span>

        <span class="cov0" title="0">result, warnings, err := scanner.Run()
        if len(*warnings) &gt; 0 </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        fmt.Printf("run finished with warnings: %s\n", *warnings)
                }</span> // Warnings are non-critical errors from nmap.
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to run nmap scan: %v", err)
        }</span>

        // No current functionality for this. Leaving here for potential future use.
        // utils.TimesSwept = 0

        <span class="cov0" title="0">return result.Hosts</span>
}

// TcpPortSweepWithTopPorts runs the quickest port sweep on TCP
func TcpPortSweepWithTopPorts(target string, OptTopPorts *string, OptVVerbose *bool) []nmap.Host <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
        defer cancel()

        topPorts, err := strconv.Atoi(*OptTopPorts)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to convert top ports var: %v", err)
        }</span>

        <span class="cov0" title="0">scanner, err := nmap.NewScanner(
                ctx,
                nmap.WithMostCommonPorts(topPorts),
                nmap.WithTargets(target),
                nmap.WithMinRate(2000),
                nmap.WithPrivileged(),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to create nmap scanner: %v", err)
        }</span>

        <span class="cov0" title="0">result, warnings, err := scanner.Run()
        if len(*warnings) &gt; 0 </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        fmt.Printf("run finished with warnings: %s\n", *warnings)
                }</span> // Warnings are non-critical errors from nmap.
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to run nmap scan: %v", err)
        }</span>

        <span class="cov0" title="0">return result.Hosts</span>
}

// UdpPortSweep runs a quick port sweep on UDP
func UdpPortSweep(target string, OptVVerbose *bool) []nmap.Host <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
        defer cancel()

        // Equivalent to `/usr/local/bin/nmap -sU -p111,161,162,10161,10162,623 --min-rate=2000 --privileged &lt;target&gt;`,
        // with a 15-minute timeout.
        scanner, err := nmap.NewScanner(
                ctx,
                nmap.WithTargets(target),
                nmap.WithUDPScan(),
                nmap.WithPorts("111,161,162,10161,10162,623"),
                nmap.WithMinRate(2000),
                nmap.WithPrivileged(),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to create nmap scanner udpPortSweep: %s %v", target, err)
        }</span>

        <span class="cov0" title="0">result, warnings, err := scanner.Run()
        if len(*warnings) &gt; 0 </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        log.Printf("run finished with warnings: %s\n", *warnings)
                }</span> // Warnings are non-critical errors from nmap.
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to run nmap scan udpPortSweep: %v", err)
        }</span>

        <span class="cov0" title="0">return result.Hosts</span>
}

// SlowerUdpPortSweep runs a slower port sweep on UDP
func SlowerUdpPortSweep(target string, OptVVerbose *bool) []nmap.Host <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
        defer cancel()

        // Equivalent to `/usr/local/bin/nmap -sU -p111,161,162,10161,10162,623 --min-rate=2000 --privileged &lt;target&gt;`,
        // with a 15-minute timeout.
        scanner, err := nmap.NewScanner(
                ctx,
                nmap.WithTargets(target),
                nmap.WithUDPScan(),
                nmap.WithPorts("111,161,162,10161,10162,623"),
                nmap.WithMinRate(500),
                nmap.WithPrivileged(),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to create nmap scanner udpPortSweep: %s %v", target, err)
        }</span>

        <span class="cov0" title="0">result, warnings, err := scanner.Run()
        if len(*warnings) &gt; 0 </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        log.Printf("run finished with warnings: %s\n", *warnings)
                }</span> // Warnings are non-critical errors from nmap.
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to run nmap scan udpPortSweep: %v", err)
        }</span>

        <span class="cov0" title="0">return result.Hosts</span>
}

// IndividualPortScannerWithNSEScripts runs Nmap scan with NSE scripts
func IndividualPortScannerWithNSEScripts(target, port, outFile, scripts string, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.PrintCustomBiColourMsg("yellow", "cyan", "[!] Starting nmap scan against port(s) '", port, "' on target '", target, "' and sending it to the background")

        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
        defer cancel()

        scanner, err := nmap.NewScanner(
                ctx,
                nmap.WithTargets(target),
                nmap.WithPorts(port),
                nmap.WithPrivileged(),
                nmap.WithMinRate(500),
                nmap.WithDisabledDNSResolution(),
                nmap.WithDefaultScript(),
                nmap.WithServiceInfo(),
                nmap.WithNmapOutput(outFile+".nmap"),
                nmap.WithGrepOutput(outFile+".grep"),
                nmap.WithScripts(scripts),
                nmap.WithSkipHostDiscovery(),
                nmap.WithVerbosity(2),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to create nmap scanner individualPortScannerWithNSEScripts: %s %s %s %v", target, port, outFile, err)
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(2 * time.Minute)
        done := make(chan bool)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case t := &lt;-ticker.C:<span class="cov0" title="0">
                                utils.PrintCustomBiColourMsg("cyan", "yellow", "[*] Individual protocol nmap scan with NSE Scripts still running against port(s) '", port, "' on target '", target, "'. Please wait...")
                                if *OptVVerbose </span><span class="cov0" title="0">{
                                        fmt.Println(utils.Debug(t))
                                }</span>
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">_, warnings, err := scanner.Run()
        if len(*warnings) &gt; 0 </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        log.Printf("run finished with warnings: %s\n", *warnings)
                }</span> // Warnings are non-critical errors from nmap.
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("unable to run nmap scan individualPortScannerWithNSEScripts: %s %s %s %v", target, port, outFile, err)
        }</span>

        <span class="cov0" title="0">ticker.Stop()
        done &lt;- true

        utils.PrintCustomBiColourMsg("green", "cyan", "[+] Done! nmap scan against port(s) '", port, "' on target '", target, "' finished successfully")
        fmt.Println(utils.Yellow("\tShortcut: less -R"), utils.Cyan(outFile+".nmap"))</span>
}

// IndividualPortScannerWithNSEScriptsAndScriptArgs runs Nmap scan with NSE scripts and NSE script arguments
func IndividualPortScannerWithNSEScriptsAndScriptArgs(target, port, outFile, scripts string, scriptArgs map[string]string, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.PrintCustomBiColourMsg("yellow", "cyan", "[!] Starting nmap scan against port(s) '", port, "' on target '", target, "' and sending it to the background")

        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
        defer cancel()

        scanner, err := nmap.NewScanner(
                ctx,
                nmap.WithTargets(target),
                nmap.WithPorts(port),
                nmap.WithPrivileged(),
                nmap.WithMinRate(500),
                nmap.WithDisabledDNSResolution(),
                nmap.WithDefaultScript(),
                nmap.WithServiceInfo(),
                nmap.WithNmapOutput(outFile+".nmap"),
                nmap.WithGrepOutput(outFile+".grep"),
                nmap.WithScripts(scripts),
                nmap.WithScriptArguments(scriptArgs),
                nmap.WithSkipHostDiscovery(),
                nmap.WithVerbosity(2),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to create nmap scanner individualPortScannerWithNSEScriptsAndScriptArgs: %s %s %s %v", target, port, outFile, err)
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(2 * time.Minute)
        done := make(chan bool)

        go func(OptVVerbose *bool) </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case t := &lt;-ticker.C:<span class="cov0" title="0">
                                utils.PrintCustomBiColourMsg("cyan", "yellow", "[*] Individual protocol nmap scan with NSE scripts and args still running against port(s) '", port, "' on target '", target, "'. Please wait...")
                                if *OptVVerbose </span><span class="cov0" title="0">{
                                        fmt.Println(utils.Debug(t))
                                }</span>
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }(OptVVerbose)

        <span class="cov0" title="0">_, warnings, err := scanner.Run()
        if len(*warnings) &gt; 0 </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        log.Printf("run finished with warnings: %s\n", *warnings)
                }</span> // Warnings are non-critical errors from nmap.
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("unable to run nmap scan individualPortScannerWithNSEScriptsAndScriptArgs: %s %s %s %v", target, port, outFile, err)
        }</span>

        <span class="cov0" title="0">ticker.Stop()
        done &lt;- true

        utils.PrintCustomBiColourMsg("green", "cyan", "[+] Done! nmap scan against port(s) '", port, "' on target '", target, "' finished successfully")
        fmt.Println(utils.Yellow("\tShortcut: less -R"), utils.Cyan(outFile+".nmap"))</span>
}

// IndividualUDPPortScannerWithNSEScripts runs a UDP Nmap scan with NSE scripts
func IndividualUDPPortScannerWithNSEScripts(target, port, outFile, scripts string, OptVVerbose *bool) <span class="cov0" title="0">{
        utils.PrintCustomBiColourMsg("yellow", "cyan", "[!] Starting UDP scan against port(s) '", port, "' on target '", target, "' and sending it to the background")

        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
        defer cancel()

        scanner, err := nmap.NewScanner(
                ctx,
                nmap.WithTargets(target),
                nmap.WithUDPScan(),
                nmap.WithPorts(port),
                nmap.WithPrivileged(),
                nmap.WithMinRate(500),
                nmap.WithDisabledDNSResolution(),
                nmap.WithDefaultScript(),
                nmap.WithServiceInfo(),
                nmap.WithNmapOutput(outFile+".nmap"),
                nmap.WithGrepOutput(outFile+".grep"),
                nmap.WithScripts(scripts),
                nmap.WithSkipHostDiscovery(),
                nmap.WithVerbosity(2),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to create nmap scanner individualUDPPortScannerWithNSEScripts: %s %s %s %v", target, port, outFile, err)
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(2 * time.Minute)
        done := make(chan bool)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case t := &lt;-ticker.C:<span class="cov0" title="0">
                                utils.PrintCustomBiColourMsg("cyan", "yellow", "[*] Individual protocol nmap scan on UDP with NSE scripts still running against port(s) '", port, "' on target '", target, "'. Please wait...")
                                if *OptVVerbose </span><span class="cov0" title="0">{
                                        fmt.Println(utils.Debug(t))
                                }</span>
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">_, warnings, err := scanner.Run()
        if len(*warnings) &gt; 0 </span><span class="cov0" title="0">{
                if *OptVVerbose </span><span class="cov0" title="0">{
                        log.Printf("run finished with warnings: %s\n", *warnings)
                }</span> // Warnings are non-critical errors from nmap.
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("unable to run nmap scan individualUDPPortScannerWithNSEScripts: %s %s %s %v", target, port, outFile, err)
        }</span>

        <span class="cov0" title="0">ticker.Stop()
        done &lt;- true

        utils.PrintCustomBiColourMsg("green", "cyan", "[+] Done! UDP scan against port(s) '", port, "' on target '", target, "' finished successfully")
        fmt.Println(utils.Yellow("\tShortcut: less"), utils.Cyan(outFile+".nmap"))</span>
}

// IndividualPortScanner runs a simple Nmap scan
func IndividualPortScanner(target, port, outFile string, OptVVerbose *bool) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
        defer cancel()

        scanner, err := nmap.NewScanner(
                ctx,
                nmap.WithTargets(target),
                nmap.WithPorts(port),
                nmap.WithPrivileged(),
                nmap.WithMinRate(500),
                nmap.WithDisabledDNSResolution(),
                nmap.WithDefaultScript(),
                nmap.WithServiceInfo(),
                nmap.WithNmapOutput(outFile+".nmap"),
                nmap.WithGrepOutput(outFile+".grep"),
                nmap.WithSkipHostDiscovery(),
                nmap.WithVerbosity(2),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to create nmap scanner individualPortScanner: %s %s %s %v", target, port, outFile, err)
        }</span>

        <span class="cov0" title="0">var lapsedMutex sync.Mutex
        lapsed := 0
        ticker := time.NewTicker(1 * time.Minute)
        done := make(chan bool, 1) // Buffered to prevent goroutine leak

        go func(OptVVerbose *bool) </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case t := &lt;-ticker.C:<span class="cov0" title="0">
                                if *OptVVerbose </span><span class="cov0" title="0">{
                                        fmt.Println(utils.Debug("Very verbose - ticker.C contents:", t))
                                }</span>

                                <span class="cov0" title="0">lapsedMutex.Lock()
                                lapsed++
                                currentLapsed := lapsed
                                lapsedMutex.Unlock()

                                if currentLapsed == 1 </span><span class="cov0" title="0">{
                                        utils.PrintCustomBiColourMsg("cyan", "yellow", "[*] Individual protocol nmap scan still running against port(s) '", port, "' on target '", target, "'. Time lapsed: '", "1", "' minute. Please wait...")
                                }</span> else<span class="cov0" title="0"> {
                                        utils.PrintCustomBiColourMsg("cyan", "yellow", "[*] Individual protocol nmap scan still running against port(s) '", port, "' on target '", target, "'. Time lapsed: '", strconv.Itoa(currentLapsed), "' minutes. Please wait...")
                                }</span>
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }(OptVVerbose)

        <span class="cov0" title="0">_, _, err = scanner.Run()
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("unable to run nmap scan individualPortScanner: %s %s %s %v", target, port, outFile, err))
        }</span>

        <span class="cov0" title="0">ticker.Stop()
        select </span>{
        case done &lt;- true:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // Goroutine already exited, don't block
        }

        <span class="cov0" title="0">utils.PrintCustomBiColourMsg("green", "cyan", "[+] Done! Nmap scan against port(s) '", port, "' on target '", target, "' finished successfully")
        fmt.Println(utils.Yellow("\tShortcut: less"), utils.Cyan(outFile+".nmap"))</span>
}

// FullAggressiveScan runs main aggressive scan for all open ports on the target
func FullAggressiveScan(target, ports, outFile string, OptVVerbose *bool) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
        defer cancel()

        scanner, err := nmap.NewScanner(
                ctx,
                nmap.WithTargets(target),
                nmap.WithPorts(ports),
                nmap.WithPrivileged(),
                nmap.WithDisabledDNSResolution(),
                nmap.WithNmapOutput(outFile+".nmap"),
                nmap.WithOSDetection(),
                nmap.WithServiceInfo(),
                nmap.WithDefaultScript(),
                nmap.WithGrepOutput(outFile+".grep"),
                nmap.WithSkipHostDiscovery(),
                nmap.WithVerbosity(2),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to create nmap scanner fullAggressiveScan: %v", err)
        }</span>

        <span class="cov0" title="0">var lapsedMutex sync.Mutex
        lapsed := 0
        ticker := time.NewTicker(1 * time.Minute)
        done := make(chan bool, 1) // Buffered to prevent goroutine leak

        go func(OptVVerbose *bool) </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case t := &lt;-ticker.C:<span class="cov0" title="0">
                                if *OptVVerbose </span><span class="cov0" title="0">{
                                        fmt.Println(utils.Debug("Very verbose - ticker.C contents:", t))
                                }</span>

                                <span class="cov0" title="0">lapsedMutex.Lock()
                                lapsed++
                                currentLapsed := lapsed
                                lapsedMutex.Unlock()

                                if currentLapsed == 1 </span><span class="cov0" title="0">{
                                        utils.PrintCustomBiColourMsg("cyan", "yellow", "[*] Main nmap scan still running against all open ports on target '", target, "'. Time lapsed: '", "1", "' minute. Please wait...")
                                }</span> else<span class="cov0" title="0"> {
                                        utils.PrintCustomBiColourMsg("cyan", "yellow", "[*] Main nmap scan still running against all open ports on target '", target, "'. Time lapsed: '", strconv.Itoa(currentLapsed), "' minutes. Please wait...")
                                }</span>
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }(OptVVerbose)

        <span class="cov0" title="0">_, _, err = scanner.Run()
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("unable to run nmap scan fullAggressiveScan: %s %s %s %v", target, ports, outFile, err))
        }</span>

        <span class="cov0" title="0">ticker.Stop()
        select </span>{
        case done &lt;- true:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // Goroutine already exited, don't block
        }

        <span class="cov0" title="0">utils.PrintCustomBiColourMsg("green", "cyan", "[+] Done! ", "Main aggressive nmap", " against all open ports on target '", target, "' finished successfully")
        fmt.Println(utils.Yellow("\tShortcut: less"), utils.Cyan(outFile+".nmap"))</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package utils

import (
        "archive/zip"
        "bufio"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "time"

        "golang.org/x/net/html"
        "github.com/Ullaakut/nmap/v3"
        "github.com/fatih/color"
        "github.com/mattn/go-zglob"
)

// Host is a struct that holds the OS and architecture of the host to identify the correct tools to install
type Host struct {
        OS   string
        Arch string
}

// Declare global variables available throughout Enumeraga
var (
        HostOS = Host{
                OS:   runtime.GOOS,
                Arch: runtime.GOARCH,
        }

        // Yellow prints a message in yellow colour
        Yellow = color.New(color.FgYellow).SprintFunc()

        // Red prints a message in red colour
        Red = color.New(color.FgRed).SprintFunc()

        // Green prints a message in green colour
        Green = color.New(color.FgHiGreen).SprintFunc()

        // Cyan prints a message in cyan colour
        Cyan = color.New(color.FgCyan).SprintFunc()

        // Debug prints a message in magenta colour
        Debug = color.New(color.FgMagenta).SprintFunc()

        // DarkwebTop1000 and others below are globally available wordlists
        DarkwebTop1000 string
        ExtensionsList string
        UsersList      string
        SnmpList       string
        DirListMedium  string

        // TimesSwept keeps track of how many ports have been tried to be swept for a host
        TimesSwept int

        // Declare globals updated and wordlistsLocated, as these may consume a lot of time and aren't needed more than once
        Updated, wordlistsLocated bool

        // Interrupted global, to show user different info if single IP target was unsuccessful
        Interrupted bool

        // Sync: Define a mutex to synchronize access to standard output
        outputMutex sync.Mutex

        // Wg sync: Define a WaitGroup to generate goroutines
        Wg sync.WaitGroup

        BaseDir      string
        Target       string
        Version      string
        VisitedSMTP  bool
        VisitedHTTP  bool
        VisitedIMAP  bool
        VisitedSMB   bool
        VisitedSNMP  bool
        VisitedLDAP  bool
        VisitedRsvc  bool
        VisitedWinRM bool
        VisitedFTP   bool
)

func PrintBanner() <span class="cov0" title="0">{
        fmt.Printf("\n%s\n", Cyan("                                                     ", Version))
        fmt.Printf("%s%s%s\n", Yellow(" __________                                    ________"), Cyan("________"), Yellow("______ "))
        fmt.Printf("%s%s%s\n", Yellow(" ___  ____/__________  ________ __________________    |"), Cyan("_  ____/"), Yellow("__    |"))
        fmt.Printf("%s%s%s\n", Yellow(" __  __/  __  __ \\  / / /_  __ `__ \\  _ \\_  ___/_  /| |"), Cyan("  / __ "), Yellow("__  /| |"))
        fmt.Printf("%s%s%s\n", Yellow(" _  /___  _  / / / /_/ /_  / / / / /  __/  /   _  ___ "), Cyan("/ /_/ / "), Yellow("_  ___ |"))
        fmt.Printf("%s%s%s\n", Yellow(" /_____/  /_/ /_/\\__,_/ /_/ /_/ /_/\\___//_/    /_/  |_"), Cyan("\\____/  "), Yellow("/_/  |_|"))
        fmt.Printf("%s\n\n", Green("                            by 0x5ubt13"))
}</span>

// ValidateIP checks if the provided string is a valid IPv4 or IPv6 address
func ValidateIP(ip string) error <span class="cov6" title="8">{
        parsed := net.ParseIP(ip)
        if parsed == nil </span><span class="cov4" title="4">{
                return fmt.Errorf("invalid IP address: %s", ip)
        }</span>
        <span class="cov4" title="4">return nil</span>
}

// ResolveHostToIP resolves a hostname or URL to an IP address
// It accepts domain names (example.com), URLs (http://example.com), and already-valid IPs
// Returns the resolved IP address or error if resolution fails
func ResolveHostToIP(host string) (string, error) <span class="cov6" title="9">{
        // First, try to parse as IP address - if it's already an IP, return it
        if ip := net.ParseIP(host); ip != nil </span><span class="cov2" title="2">{
                return host, nil
        }</span>

        // Remove common URL schemes if present (http://, https://, etc.)
        <span class="cov6" title="7">host = strings.TrimPrefix(host, "http://")
        host = strings.TrimPrefix(host, "https://")
        host = strings.TrimPrefix(host, "ftp://")

        // Remove path components if URL contains them
        if idx := strings.Index(host, "/"); idx != -1 </span><span class="cov1" title="1">{
                host = host[:idx]
        }</span>

        // Remove port if present
        <span class="cov6" title="7">if idx := strings.Index(host, ":"); idx != -1 </span><span class="cov1" title="1">{
                host = host[:idx]
        }</span>

        // Try to parse again after cleanup - maybe it was a URL with an IP
        <span class="cov6" title="7">if ip := net.ParseIP(host); ip != nil </span><span class="cov4" title="4">{
                return host, nil
        }</span>

        // Perform DNS lookup
        <span class="cov3" title="3">ips, err := net.LookupIP(host)
        if err != nil </span><span class="cov2" title="2">{
                return "", fmt.Errorf("failed to resolve hostname %s: %v", host, err)
        }</span>

        <span class="cov1" title="1">if len(ips) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no IP addresses found for hostname: %s", host)
        }</span>

        // Return the first IPv4 address found, or first IPv6 if no IPv4 exists
        <span class="cov1" title="1">for _, ip := range ips </span><span class="cov1" title="1">{
                if ipv4 := ip.To4(); ipv4 != nil </span><span class="cov1" title="1">{
                        return ipv4.String(), nil
                }</span>
        }

        // If no IPv4 found, return first IPv6
        <span class="cov0" title="0">return ips[0].String(), nil</span>
}

// ValidateCIDR checks if the provided string is a valid CIDR notation
func ValidateCIDR(cidr string) error <span class="cov6" title="9">{
        _, _, err := net.ParseCIDR(cidr)
        if err != nil </span><span class="cov5" title="5">{
                return fmt.Errorf("invalid CIDR range: %s - %v", cidr, err)
        }</span>
        <span class="cov4" title="4">return nil</span>
}

// ValidatePort checks if the provided port number is valid (1-65535)
func ValidatePort(port string) error <span class="cov10" title="30">{
        portNum, err := strconv.Atoi(port)
        if err != nil </span><span class="cov4" title="4">{
                return fmt.Errorf("invalid port number: %s - not a number", port)
        }</span>
        <span class="cov9" title="26">if portNum &lt; 1 || portNum &gt; 65535 </span><span class="cov4" title="4">{
                return fmt.Errorf("invalid port number: %d - must be between 1 and 65535", portNum)
        }</span>
        <span class="cov9" title="22">return nil</span>
}

// ValidatePorts checks if the provided comma-separated port list is valid
func ValidatePorts(ports string) error <span class="cov7" title="11">{
        portList := strings.Split(ports, ",")
        for _, port := range portList </span><span class="cov9" title="21">{
                port = strings.TrimSpace(port)
                if port == "" </span><span class="cov3" title="3">{
                        continue</span>
                }
                // Handle port ranges like "1-100"
                <span class="cov8" title="18">if strings.Contains(port, "-") </span><span class="cov4" title="4">{
                        rangeParts := strings.Split(port, "-")
                        if len(rangeParts) != 2 </span><span class="cov1" title="1">{
                                return fmt.Errorf("invalid port range format: %s", port)
                        }</span>
                        <span class="cov3" title="3">if err := ValidatePort(rangeParts[0]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov3" title="3">if err := ValidatePort(rangeParts[1]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov3" title="3">start, _ := strconv.Atoi(rangeParts[0])
                        end, _ := strconv.Atoi(rangeParts[1])
                        if start &gt; end </span><span class="cov1" title="1">{
                                return fmt.Errorf("invalid port range: %s - start port greater than end port", port)
                        }</span>
                } else<span class="cov7" title="14"> {
                        if err := ValidatePort(port); err != nil </span><span class="cov2" title="2">{
                                return err
                        }</span>
                }
        }
        <span class="cov6" title="7">return nil</span>
}

// ValidateFilePath checks if the provided file path exists and is readable
func ValidateFilePath(path string) error <span class="cov4" title="4">{
        info, err := os.Stat(path)
        if os.IsNotExist(err) </span><span class="cov2" title="2">{
                return fmt.Errorf("file does not exist: %s", path)
        }</span>
        <span class="cov2" title="2">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error accessing file: %s - %v", path, err)
        }</span>
        <span class="cov2" title="2">if info.IsDir() </span><span class="cov1" title="1">{
                return fmt.Errorf("path is a directory, not a file: %s", path)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func PrintInfraUsageExamples() <span class="cov0" title="0">{
        e := color.WhiteString("enumeraga ")

        // Print "examples" in white
        fmt.Printf("\nExamples:\n ")
        PrintCustomBiColourMsg(
                "cyan", "yellow",
                e, "-i\n ",
                e, "-bq -t ", "10.10.11.230", "\n ",
                e, "-V -r ", "10.129.121.0/24", " -t ", "10.129.121.60", "\n ",
                e, "-t ", "targets_file.txt", " -r ", "10.10.8.0/24",
        )
}</span>

func PrintCloudUsageExamples() <span class="cov0" title="0">{
        e := color.WhiteString("enumeraga cloud ")

        // Print "examples" in white
        fmt.Printf("\nExamples:\n ")
        PrintCustomBiColourMsg(
                "cyan", "yellow",
                e, "aws\n ",
                e, "gcp\n ",
                e, "azure\n ",
        )
}</span>

// Check if OS is debian-like
func isCompatibleDistro() error <span class="cov0" title="0">{
        cat := exec.Command("cat", "/etc/os-release")
        output, err := cat.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading /etc/os-release: %v\n", err)
                os.Exit(5)
        }</span>

        <span class="cov0" title="0">compatibleDistro := strings.Contains(strings.ToLower(string(output)), "debian")
        if !compatibleDistro </span><span class="cov0" title="0">{
                ErrorMsg("This system is not running a Debian-like distribution. Please install the tools manually.")
                return fmt.Errorf("not compatible distro")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ErrorMsg gets a custom error message printed out to terminal
func ErrorMsg(errMsg any) <span class="cov1" title="1">{
        fmt.Printf("%s %s\n", Red("[-] Error detected:"), errMsg)
}</span>

// ReadTargetsFile from the argument path passed to -t; returns number of targets, one per line
func ReadTargetsFile(optTarget *string) ([]string, int) <span class="cov6" title="7">{
        data, err := os.ReadFile(*optTarget)
        if err != nil </span><span class="cov1" title="1">{
                ErrorMsg(fmt.Sprintf("Failed to read targets file: %v", err))
                return nil, 0
        }</span>

        // Get lines
        <span class="cov5" title="6">lines := strings.Split(string(data), "\n")
        // Filter out empty lines
        nonEmptyLines := make([]string, 0, len(lines))
        for _, line := range lines </span><span class="cov8" title="19">{
                trimmedLine := strings.TrimSpace(line)
                if trimmedLine != "" </span><span class="cov6" title="8">{
                        nonEmptyLines = append(nonEmptyLines, trimmedLine)
                }</span>
        }
        <span class="cov5" title="6">return nonEmptyLines, len(nonEmptyLines)</span>
}

// CustomMkdir checks first if it is possible to create new dir, and send custom msg if not.
func CustomMkdir(name string) (string, error) <span class="cov0" title="0">{
        err := os.MkdirAll(name, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return name, nil</span>
}

// ProtocolDetected announces protocol, creates base dir and returns its name
func ProtocolDetected(protocol, baseDir string) string <span class="cov0" title="0">{
        PrintCustomBiColourMsg("green", "cyan", "[+] '", protocol, "' service detected")

        protocolDir := fmt.Sprintf("%s%s/", baseDir, strings.ToLower(protocol))
        _, err := CustomMkdir(protocolDir)
        if err != nil </span><span class="cov0" title="0">{
                ErrorMsg(fmt.Sprintf("Error creating protocol directory: %v", err))
        }</span>

        <span class="cov0" title="0">return protocolDir</span>
}

func WriteTextToFile(filePath string, message string) error <span class="cov4" title="4">{
        // Open file
        f, err := os.Create(filePath)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create file %s: %w", filePath, err)
        }</span>
        <span class="cov3" title="3">defer func(f *os.File) </span><span class="cov3" title="3">{
                if closeErr := f.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        ErrorMsg(fmt.Sprintf("Error closing file %s: %v", filePath, closeErr))
                }</span>
        }(f)

        // Write to it
        <span class="cov3" title="3">if _, err := fmt.Fprintln(f, message); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to file %s: %w", filePath, err)
        }</span>
        <span class="cov3" title="3">return nil</span>
}

func WritePortsToFile(filePath string, ports string, host string) (string, error) <span class="cov3" title="3">{
        // Open file
        fileName := fmt.Sprintf("%sopen_ports.txt", filePath)
        f, err := os.Create(fileName)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create ports file %s: %w", fileName, err)
        }</span>
        <span class="cov3" title="3">defer func(f *os.File) </span><span class="cov3" title="3">{
                if closeErr := f.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        ErrorMsg(fmt.Sprintf("Error closing file %s: %v", fileName, closeErr))
                }</span>
        }(f)

        // Write to it
        <span class="cov3" title="3">if _, err := fmt.Fprintln(f, ports); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write ports to file %s: %w", fileName, err)
        }</span>
        <span class="cov3" title="3">PrintCustomBiColourMsg("green", "yellow", "[+] Successfully written open ports for host '", host, "' to file '", fileName, "'")

        return ports, nil</span>
}

// FinishLine finishes the main flow with time tracker and prints a couple nice messages to the terminal
func FinishLine(start time.Time, interrupted bool) <span class="cov0" title="0">{
        elapsed := time.Since(start)
        var output string

        if elapsed.Seconds() &lt; 1 </span><span class="cov0" title="0">{
                // Convert duration to float of Milliseconds
                ms := float64(elapsed.Nanoseconds()) / 1e6
                output = fmt.Sprintf("%.2fms", ms)
        }</span> else<span class="cov0" title="0"> {
                // Convert duration to float of Seconds
                s := elapsed.Seconds()
                output = fmt.Sprintf("%.2fs", s)
        }</span>

        <span class="cov0" title="0">if interrupted </span><span class="cov0" title="0">{
                PrintCustomBiColourMsg("cyan", "green", "\n[*] Done! It only took '", output, "' to run ", "Enumeraga", "'s core functionality, although an error was detected.\n\tPlease check your arguments, program's output or connectivity and try again.\n")
                return
        }</span>

        <span class="cov0" title="0">PrintCustomBiColourMsg("cyan", "green", "\n[*] Done! It only took '", output, "' to run ", "Enumeraga ", "based on your settings!! Please allow your tools some time to finish.")
        fmt.Printf("%s%s%s\n\n", Cyan("[*] ---------- "), Green("Enumeration phase complete"), Cyan(" ----------"))
        fmt.Printf("%s%s%s\n", Cyan("[*] ---------- "), Green("Program complete. Awaiting tools to finish"), Cyan(" ----------"))</span>
}

// RemoveDuplicates removes duplicate ports from the comma-separated ports string
func RemoveDuplicates(s string) string <span class="cov5" title="5">{
        parts := strings.Split(s, ",")
        seen := make(map[string]bool)
        result := make([]string, 0)

        for _, part := range parts </span><span class="cov7" title="14">{
                if !seen[part] </span><span class="cov6" title="9">{
                        seen[part] = true
                        result = append(result, part)
                }</span>
        }
        <span class="cov5" title="5">return strings.Join(result, ",")</span>
}

// GetOpenPortsSlice creates a string slice using strconv.FormatUint and append strings to it.
func GetOpenPortsSlice(sweptHostTcp, sweptHostUdp []nmap.Host) []string <span class="cov0" title="0">{
        openPortsSlice := make([]string, 0)

        for _, host := range sweptHostTcp </span><span class="cov0" title="0">{
                if len(host.Ports) == 0 || len(host.Addresses) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, port := range host.Ports </span><span class="cov0" title="0">{
                        // Error below: String(port.State) not working for some reason, but linter saying use String(); therefore, using Sprintf regardless
                        if fmt.Sprintf("%s", port.State) == "open" </span><span class="cov0" title="0">{
                                text := strconv.FormatUint(uint64(port.ID), 10)
                                openPortsSlice = append(openPortsSlice, text)
                        }</span>
                }
        }

        // Same than above but for the swept ports running on UDP
        <span class="cov0" title="0">for _, host := range sweptHostUdp </span><span class="cov0" title="0">{
                if len(host.Ports) == 0 || len(host.Addresses) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, port := range host.Ports </span><span class="cov0" title="0">{
                        // Error below: String(port.State) not working for some reason, but linter saying use String(); therefore, using Sprintf regardless
                        if fmt.Sprintf("%s", port.State) == "open" </span><span class="cov0" title="0">{
                                text := strconv.FormatUint(uint64(port.ID), 10)
                                openPortsSlice = append(openPortsSlice, text)
                        }</span>
                }
        }
        <span class="cov0" title="0">return openPortsSlice</span>
}

// Consent asks for user consent
func Consent(tool string) rune <span class="cov0" title="0">{
        PrintCustomBiColourMsg("red", "cyan", "[-] ", "Enumeraga ", "needs ", tool, " to be installed")
        PrintCustomBiColourMsg("yellow", "cyan", "Do you want to install '", tool, "' (", "[Y]", " 'yes' / ", "[N]", " 'no' / ", "[A]", " 'yes to all'): ")

        consent := bufio.NewScanner(os.Stdin)
        consent.Scan()
        userInput := strings.ToLower(consent.Text())

        if userInput == "yes" || userInput == "y" </span><span class="cov0" title="0">{
                return 'y'
        }</span>

        <span class="cov0" title="0">if userInput == "all" || userInput == "a" </span><span class="cov0" title="0">{
                return 'a'
        }</span>

        // If flow made it to down here, consent wasn't given
        <span class="cov0" title="0">printConsentNotGiven(tool)
        return 'n'</span>
}

// OSCPConsent asks for user consent to run any forbidden tool for OSCP
func OSCPConsent(tool string) rune <span class="cov0" title="0">{
        PrintCustomBiColourMsg("red", "cyan", "[-] ", "Enumeraga ", "needs ", tool, " to be run, which won't be very good if you're trying OSCP ")
        PrintCustomBiColourMsg("yellow", "cyan", "Do you want to run '", tool, "' (", "[Y]", " 'yes' / ", "[N]", " 'no' / ", "[A]", " 'yes to all'): ")

        consent := bufio.NewScanner(os.Stdin)
        consent.Scan()
        userInput := strings.ToLower(consent.Text())

        if userInput == "yes" || userInput == "y" </span><span class="cov0" title="0">{
                return 'y'
        }</span>

        <span class="cov0" title="0">if userInput == "all" || userInput == "a" </span><span class="cov0" title="0">{
                return 'a'
        }</span>

        // If flow made it to down here, consent wasn't given
        <span class="cov0" title="0">printOSCPConsentNotGiven(tool)
        return 'n'</span>
}

// CheckToolExists checks that the tool exists with exec.LookPath (equivalent to `which &lt;tool&gt;`)
func CheckToolExists(tool string) bool <span class="cov0" title="0">{
        _, lookPatherr := exec.LookPath(tool)
        return lookPatherr == nil
}</span>

// Separate function to add key tools
func getKeyTools() []string <span class="cov0" title="0">{
        return []string{
                "cewl",
                "enum4linux-ng",
                "dirsearch",
                "finger",
                "ffuf",
                "fping",
                "hydra",
                "ident-user-enum",
                "impacket-rpcdump",
                "msfconsole",
                "nbtscan-unixwiz",
                "nikto",
                "nmap",
                // TODO: add nuclei!!!
                "odat",
                "responder-RunFinger",
                "rusers",
                "seclists",
                "smbclient",
                "ssh-audit",
                "testssl",
                "wafw00f",
                "whatweb",
        }
}</span>

func getKeyCloudTools() []string <span class="cov0" title="0">{
        return []string{
                "prowler",    // (https://github.com/prowler-cloud/prowler)
                "scoutsuite", // (https://github.com/nccgroup/scoutsuite)
                "cloudfox",   // (https://github.com/BishopFox/cloudfox)
                /*
                        Note: it'd be good if pmapper was installed alongside cloudfox, with their integration it could also have it generate the default privesc query and images as output
                                - Pmapper (https://github.com/nccgroup/PMapper)
                                - Steampipe (https://github.com/turbot/steampipe)
                                - Powerpipe (https://github.com/turbot/powerpipe)
                */
        }
}</span>

// InstallMissingTools instructs the program to try and install tools that are absent from the pentesting distro.
// Case 'c' installs key cloud tools
// Case 'i' installs key infra tools
func InstallMissingTools(kind rune, optInstall *bool) <span class="cov0" title="0">{
        if *optInstall </span><span class="cov0" title="0">{
                fmt.Println(Cyan("[*] Install flag detected. Aborting other checks and running pre-requisites check.\n"))
        }</span>

        <span class="cov0" title="0">var keyTools []string
        switch kind </span>{
        case 'c':<span class="cov0" title="0">
                keyTools = getKeyCloudTools()</span>
        case 'i':<span class="cov0" title="0">
                keyTools = getKeyTools()</span>
        }

        // Loop through listed tool see which ones are missing
        <span class="cov0" title="0">var missingTools []string
        fullConsent := false
        for _, tool := range keyTools </span><span class="cov0" title="0">{
                // Check for tools conflicting with arm64
                if runtime.GOARCH == "arm64" </span><span class="cov0" title="0">{
                        if tool == "odat" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">if CheckToolExists(tool) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // If full consent was given, stop prompting the user
                <span class="cov0" title="0">if fullConsent </span><span class="cov0" title="0">{
                        missingTools = append(missingTools, tool)
                        continue</span>
                }

                // Ask user
                <span class="cov0" title="0">userConsent := Consent(tool)

                if userConsent == 'a' </span><span class="cov0" title="0">{
                        fullConsent = true
                        missingTools = append(missingTools, tool)
                }</span>

                <span class="cov0" title="0">if userConsent == 'y' </span><span class="cov0" title="0">{
                        missingTools = append(missingTools, tool)
                        continue</span>
                }
        }

        <span class="cov0" title="0">compatibilityErr := isCompatibleDistro()
        if compatibilityErr != nil </span><span class="cov0" title="0">{
                os.Exit(3)
        }</span>

        <span class="cov0" title="0">for _, tool := range missingTools </span><span class="cov0" title="0">{
                if !Updated </span><span class="cov0" title="0">{
                        AptGetUpdateCmd()
                        Updated = true
                }</span>
                <span class="cov0" title="0">AptGetInstallCmd(tool)</span>
        }
}

func PrintInstallingTool(tool string) <span class="cov0" title="0">{
        fmt.Printf("%s %s%s ", Yellow("[!] Installing"), Cyan(tool), Yellow("..."))
}</span>

func printConsentNotGiven(tool string) <span class="cov0" title="0">{
        fmt.Printf(
                "%s\n%s %s %s\n",
                Red("[-] Consent not given."),
                Red("[-] Please install"),
                Cyan(tool),
                Red("manually. Aborting..."),
        )
}</span>

func printOSCPConsentNotGiven(tool string) <span class="cov0" title="0">{
        fmt.Printf(
                "%s\n%s %s\n",
                Red("[-] Consent not given to run '"),
                Cyan(tool),
                Red(". Aborting..."),
        )
}</span>

// AptGetUpdateCmd runs the apt-get update command
func AptGetUpdateCmd() <span class="cov0" title="0">{
        fmt.Printf("%s %s%s ", Yellow("[!] Running"), Cyan("apt-get update"), Yellow("..."))
        update := exec.Command("apt-get", "update")

        // Redirect the command's error output to the standard output in terminal
        update.Stderr = os.Stderr

        // Run the command
        updateErr := update.Run()
        if updateErr != nil </span><span class="cov0" title="0">{
                ErrorMsg(fmt.Sprintf("[?] Debug -&gt; Error running apt-get update: %v\n", updateErr))
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("%s\n", Green("Done!"))</span>
}

// AptGetInstallCmd runs the apt-get install &lt;tool&gt; command
func AptGetInstallCmd(tool string) <span class="cov0" title="0">{
        // Moving to go due to import cycle
        PrintInstallingTool(tool)

        if tool == "finger" </span><span class="cov0" title="0">{
                tool = "nfs-common"
        }</span>

        <span class="cov0" title="0">if tool == "msfconsole" </span><span class="cov0" title="0">{
                tool = "metasploit-framework"
        }</span>

        <span class="cov0" title="0">if tool == "responder-RunFinger" </span><span class="cov0" title="0">{
                tool = "responder"
        }</span>

        <span class="cov0" title="0">if tool == "impacket-rpcdump" </span><span class="cov0" title="0">{
                tool = "python3-impacket"
        }</span>

        <span class="cov0" title="0">aptGetInstall := exec.Command("apt", "install", "-y", tool)

        aptGetInstallErr := aptGetInstall.Run()
        if aptGetInstallErr != nil </span><span class="cov0" title="0">{
                // Notify of enum4linux-ng as it's not currently in the official kali repo
                if tool == "enum4linux-ng" </span><span class="cov0" title="0">{
                        installErr := installEnum4linuxNg()
                        if installErr != nil </span><span class="cov0" title="0">{
                                ErrorMsg(installErr.Error())
                                PrintCustomBiColourMsg("red", "cyan", "[-] Error. ", "enum4linux-ng", " needs to be manually installed.\nPlease see: ", "https://github.com/cddmp/enum4linux-ng/blob/master/README.md#kali-linuxdebianubuntulinux-mint")
                                os.Exit(2)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">PrintCustomBiColourMsg("red", "cyan", "[-] Error. Please install the following package manually: '", tool, "'\n[-] Aborting...")
                os.Exit(2)</span>
        }

        <span class="cov0" title="0">fmt.Printf("%s\n", Green("Done!"))</span>
}

func enum4linuxNgPreReqs() <span class="cov0" title="0">{
        reqs := []string{"python3-ldap3", "python3-yaml", "python3-impacket", "pip"}
        for _, tool := range reqs </span><span class="cov0" title="0">{
                if !Updated </span><span class="cov0" title="0">{
                        AptGetUpdateCmd()
                        Updated = true
                }</span>
                <span class="cov0" title="0">AptGetInstallCmd(tool)</span>
        }
}

// gitCloneCmd clones the git repo in the system
func gitCloneCmd(repoName, repoUrl string) error <span class="cov0" title="0">{
        localDir := "/usr/share/" + repoName
        gitClone := exec.Command("git", "clone", repoUrl, localDir)

        // Redirect the command's error output to the standard output in terminal
        gitClone.Stderr = os.Stderr

        // Run the command
        gitCloneErr := gitClone.Run()
        if gitCloneErr != nil </span><span class="cov0" title="0">{
                ErrorMsg(fmt.Sprintf("Error running git clone: %v\n", gitCloneErr))
                return gitCloneErr
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// pipInstallCmd runs pip install &lt;packages&gt;
func pipInstallCmd(pipPackage ...string) error <span class="cov0" title="0">{
        if len(pipPackage) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one package must be passed to the function")
        }</span>

        <span class="cov0" title="0">args := append([]string{"install", "--break-system-packages"}, pipPackage...)
        pipInstall := exec.Command("pip", args...)

        // Redirect the command's error output to the standard output in terminal
        pipInstall.Stderr = os.Stderr

        // Run the command
        pipInstallErr := pipInstall.Run()
        if pipInstallErr != nil </span><span class="cov0" title="0">{
                ErrorMsg(fmt.Sprintf("Very verbose - Error running pip install wheel: %v\n", pipInstallErr))
                return pipInstallErr
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// runChmod runs chmod in the system
func runChmod(command ...string) error <span class="cov0" title="0">{
        cmd := exec.Command("chmod", command[0], command[1])

        // Redirect the command's error output to the standard output in terminal
        cmd.Stderr = os.Stderr

        // Run cmd
        cmdErr := cmd.Run()
        if cmdErr != nil </span><span class="cov0" title="0">{
                ErrorMsg(fmt.Sprintf("Very verbose -&gt; Error running cmd: %v\n", cmdErr))
                return cmdErr
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// runLn links files for execution within the $PATH
func runLn(command ...string) error <span class="cov0" title="0">{
        cmd := exec.Command("ln", command[0], command[1], command[2])

        // Redirect the command's error output to the standard output in terminal
        cmd.Stderr = os.Stderr

        // Run cmd
        cmdErr := cmd.Run()
        if cmdErr != nil </span><span class="cov0" title="0">{
                ErrorMsg(fmt.Sprintf("Very verbose -&gt; Error running ln: %v\n", cmdErr))
                return cmdErr
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// installEnum4linuxNg tries to install Enum4linux-ng on behalf of the user
func installEnum4linuxNg() error <span class="cov0" title="0">{
        // Print ask for consent
        PrintCustomBiColourMsg(
                "yellow", "cyan",
                "Do you want for ", "Enumeraga ", "to try and handle the installation of '", "enum4linux-ng",
                "'?\nIt might be the case you have it in your machine but not in your $PATH.\nBear in mind that this will call '", "pip", "' as root",
        )

        // Get consent
        userInput := Consent("enum4linux-ng using pip as root")
        if userInput == 'n' </span><span class="cov0" title="0">{
                consentErr := fmt.Errorf("%s", "Error. Consent not given")
                return consentErr
        }</span>

        <span class="cov0" title="0">fmt.Printf("%s %s%s\n", Yellow("[!] Checking pre-requisites to install '"), Cyan("enum4linux-ng"), Yellow("'..."))

        // Check and installed pre-requisites
        enum4linuxNgPreReqs()

        // Run git clone "https://github.com/cddmp/enum4linux-ng"
        PrintCustomBiColourMsg("yellow", "cyan", "[!] Installing '", "enum4linux-ng", "' ...")
        gitCloneErr := gitCloneCmd("enum4linux-ng", "https://github.com/cddmp/enum4linux-ng")
        if gitCloneErr != nil </span><span class="cov0" title="0">{
                return gitCloneErr
        }</span>

        // Run pip to install wheel and clone
        <span class="cov0" title="0">pipInstallWheelAndCloneErr := pipInstallCmd("wheel", "clone")
        if pipInstallWheelAndCloneErr != nil </span><span class="cov0" title="0">{
                return pipInstallWheelAndCloneErr
        }</span>

        // Run Pip install -r requirements.txt
        <span class="cov0" title="0">pipInstallRequisitesCmd := pipInstallCmd("-r", "/usr/share/enum4linux-ng/requirements.txt")
        if pipInstallRequisitesCmd != nil </span><span class="cov0" title="0">{
                return pipInstallRequisitesCmd
        }</span>

        // Make executable
        <span class="cov0" title="0">runChmodErr := runChmod("+x", "/usr/share/enum4linux-ng/enum4linux-ng.py")
        if runChmodErr != nil </span><span class="cov0" title="0">{
                return runChmodErr
        }</span>

        // Create symbolic link
        <span class="cov0" title="0">lnErr := runLn("-s", "/usr/share/enum4linux-ng/enum4linux-ng.py", "/usr/bin/enum4linux-ng")
        if lnErr != nil </span><span class="cov0" title="0">{
                return lnErr
        }</span>

        <span class="cov0" title="0">fmt.Println(Green("Done!"))
        return nil</span>
}

func GetWordlists(optVVerbose *bool) <span class="cov0" title="0">{
        if wordlistsLocated </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">wordlistsLocated = true

        // Locate the "raft-medium-directories-lowercase" file
        dirListMediumSlice, err := zglob.Glob("/usr/share/seclists/Discovery/Web-Content/raft-medium-directories-lowercase.txt")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error locating 'raft-medium-directories-lowercase' with zglob: %v\n", err)
        }</span>
        <span class="cov0" title="0">DirListMedium = dirListMediumSlice[0]

        // Locate the "darkweb2017-top1000.txt" file
        DarkwebTop1000Slice, err := zglob.Glob("/usr/share/seclists/Passwords/darkweb2017-top1000.txt")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error locating 'darkweb2017-top1000.txt': %v\n", err)
        }</span>
        <span class="cov0" title="0">DarkwebTop1000 = DarkwebTop1000Slice[0]

        // Locate the "web-extensions.txt" file
        ExtensionsListSlice, err := zglob.Glob("/usr/share/seclists/Discovery/Web-Content/web-extensions.txt")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error locating 'web-extensions.txt': %v\n", err)
        }</span>
        <span class="cov0" title="0">ExtensionsList = ExtensionsListSlice[0]

        // Locate the "top-usernames-shortlist" file
        UsersListSlice, err := zglob.Glob("/usr/share/seclists/Usernames/top-usernames-shortlist.txt")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error locating 'top-usernames-shortlist': %v\n", err)
        }</span>
        <span class="cov0" title="0">UsersList = UsersListSlice[0]

        // Locate the "snmp-onesixtyone" file
        snmpListSlice, err := zglob.Glob("/usr/share/seclists/Discovery/SNMP/snmp-onesixtyone.txt")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error locating 'SNMP/snmp.txt': %v\n", err)
        }</span>
        <span class="cov0" title="0">SnmpList = snmpListSlice[0]

        if *optVVerbose </span><span class="cov0" title="0">{
                fmt.Println("Located Files:")
                fmt.Printf("dir_list_medium: %v\n", DirListMedium)
                fmt.Printf("darkweb_top1000: %v\n", DarkwebTop1000)
                fmt.Printf("extensions_list: %v\n", ExtensionsList)
                fmt.Printf("users_list: %v\n", UsersList)
                fmt.Printf("snmp_list: %v\n", SnmpList)
        }</span>
}

// PrintCustomBiColourMsg loops over the necessary colours, printing one at a time
func PrintCustomBiColourMsg(dominantColour, secondaryColour string, text ...string) <span class="cov3" title="3">{
        // Lock the mutex to ensure exclusive access to standard output,
        // avoiding printing different lines of output to console
        outputMutex.Lock()
        defer outputMutex.Unlock()

        for i, str := range text </span><span class="cov8" title="15">{
                if i%2 == 0 || i == 0 </span><span class="cov6" title="9">{
                        switch dominantColour </span>{
                        case "green":<span class="cov6" title="9">
                                fmt.Printf("%s", Green(str))</span>
                        case "yellow":<span class="cov0" title="0">
                                fmt.Printf("%s", Yellow(str))</span>
                        case "red":<span class="cov0" title="0">
                                fmt.Printf("%s", Red(str))</span>
                        case "cyan":<span class="cov0" title="0">
                                fmt.Printf("%s", Cyan(str))</span>
                        case "magenta":<span class="cov0" title="0">
                                fmt.Printf("%s", Debug(str))</span>
                        }
                        <span class="cov6" title="9">continue</span>
                }

                <span class="cov5" title="6">switch secondaryColour </span>{
                case "green":<span class="cov0" title="0">
                        fmt.Printf("%s", Green(str))</span>
                case "yellow":<span class="cov5" title="6">
                        fmt.Printf("%s", Yellow(str))</span>
                case "red":<span class="cov0" title="0">
                        fmt.Printf("%s", Red(str))</span>
                case "cyan":<span class="cov0" title="0">
                        fmt.Printf("%s", Cyan(str))</span>
                }
        }

        <span class="cov3" title="3">fmt.Printf("\n")</span>
}

type Asset struct {
        BrowserDownloadURL string `json:"browser_download_url"`
        Name               string `json:"name"`
}

type Release struct {
        Assets     []Asset `json:"assets"`
        ZipballURL string  `json:"zipball_url"`
}

// GetDownloadURL returns the download URL for the tool according to the user's host OS and architecture
func GetDownloadURL(tool string, latest Release) (string, error) <span class="cov0" title="0">{
        switch tool </span>{
        case "cloudfox":<span class="cov0" title="0">
                for _, asset := range latest.Assets </span><span class="cov0" title="0">{
                        if HostOS.OS == "linux" &amp;&amp; HostOS.Arch == "amd64" &amp;&amp; filepath.Ext(asset.Name) == ".zip" &amp;&amp; asset.Name == "cloudfox-linux-amd64.zip" </span><span class="cov0" title="0">{
                                return asset.BrowserDownloadURL, nil
                        }</span>
                        <span class="cov0" title="0">if HostOS.OS == "linux" &amp;&amp; HostOS.Arch == "386" &amp;&amp; filepath.Ext(asset.Name) == ".zip" &amp;&amp; asset.Name == "cloudfox-linux-386.zip" </span><span class="cov0" title="0">{
                                return asset.BrowserDownloadURL, nil
                        }</span>
                        <span class="cov0" title="0">if HostOS.OS == "darwin" &amp;&amp; HostOS.Arch == "amd64" &amp;&amp; filepath.Ext(asset.Name) == ".zip" &amp;&amp; asset.Name == "cloudfox-macos-amd64.zip" </span><span class="cov0" title="0">{
                                return asset.BrowserDownloadURL, nil
                        }</span>
                        <span class="cov0" title="0">if HostOS.OS == "darwin" &amp;&amp; HostOS.Arch == "arm64" &amp;&amp; filepath.Ext(asset.Name) == ".zip" &amp;&amp; asset.Name == "cloudfox-macos-arm64.zip" </span><span class="cov0" title="0">{
                                return asset.BrowserDownloadURL, nil
                        }</span>
                        <span class="cov0" title="0">if HostOS.OS == "windows" &amp;&amp; HostOS.Arch == "amd64" &amp;&amp; filepath.Ext(asset.Name) == ".zip" &amp;&amp; asset.Name == "cloudfox-windows-amd64.zip" </span><span class="cov0" title="0">{
                                return asset.BrowserDownloadURL, nil
                        }</span>
                }
                // Any other tool that needs downloading from GitHub can be added below:
                // case "":
                //     return return asset.BrowserDownloadURL, nil
        }

        <span class="cov0" title="0">PrintCustomBiColourMsg("magenta", "yellow", "[?] Debug -&gt; No suitable asset found. Host OS: ", HostOS.OS, " | Host Arch: ", HostOS.Arch, " | Assets: ", fmt.Sprintf("%v", latest.Assets))
        return "", fmt.Errorf("no suitable asset found")</span>
}

func DownloadFileFromURL(url string, filepath string) error <span class="cov0" title="0">{
        resp, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        out, err := os.Create(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer out.Close()

        _, err = io.Copy(out, resp.Body)
        return err</span>
}

func DownloadFromGithub(toolFullPath, downloadURL string) error <span class="cov0" title="0">{
        // Making the tool download OS-agnostic, instead of using wget
        out, err := os.Create(toolFullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating file: %v", err)
        }</span>
        <span class="cov0" title="0">defer func(out *os.File) </span><span class="cov0" title="0">{
                err := out.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ErrorMsg("error closing file")
                }</span>
        }(out)

        // Get the data
        <span class="cov0" title="0">downloadResp, err := http.Get(downloadURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error downloading file: %v", err)
        }</span>
        <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ErrorMsg(fmt.Sprintf("Error closing the request body: %v", err))
                }</span>
        }(downloadResp.Body)

        // Write the data to the file
        <span class="cov0" title="0">_, err = io.Copy(out, downloadResp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing to file: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FetchAndDownloadLatestVersionFromGitHub fetches the latest release from GitHub and downloads the tool
func FetchAndDownloadLatestVersionFromGitHub(tool string) (string, string, error) <span class="cov0" title="0">{
        // Create an OS-agnostic temp directory for the tool
        toolTmpDir := filepath.Join(os.TempDir(), tool)
        if err := os.MkdirAll(toolTmpDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("error while creating tmp dir: %v", err)
        }</span>

        <span class="cov0" title="0">var repo, toolFullPath string
        switch tool </span>{
        case "cloudfox":<span class="cov0" title="0">
                repo = "BishopFox/cloudfox"
                toolFullPath = filepath.Join(toolTmpDir, tool+".zip")</span>
        }

        <span class="cov0" title="0">assetResp, err := http.Get(fmt.Sprintf("https://api.github.com/repos/%s/releases/latest", repo))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("error while fetching latest release: %v", err)
        }</span>
        <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ErrorMsg(fmt.Sprintf("Error closing the request body: %v", err))
                }</span>
        }(assetResp.Body)

        <span class="cov0" title="0">var latestReleaseData Release
        if err := json.NewDecoder(assetResp.Body).Decode(&amp;latestReleaseData); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("error decoding latest release data: %v", err)
        }</span>

        <span class="cov0" title="0">downloadURL, err := GetDownloadURL(tool, latestReleaseData)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("error getting download URL: %v", err)
        }</span>

        <span class="cov0" title="0">PrintCustomBiColourMsg("yellow", "cyan", "[!] Suitable URL found for '", tool, "' for OS ", HostOS.OS, " and arch ", HostOS.Arch, ": ", downloadURL)

        err = DownloadFromGithub(toolFullPath, downloadURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">return toolTmpDir, toolFullPath, nil</span>
}

// Unzip extracts files from zip archives
func Unzip(src, dest string) (string, error) <span class="cov0" title="0">{
        r, err := zip.OpenReader(src)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer func(r *zip.ReadCloser) </span><span class="cov0" title="0">{
                err := r.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ErrorMsg(fmt.Sprintf("Error closing the zip reader: %v", err))
                }</span>
        }(r)

        <span class="cov0" title="0">var fpath string
        for _, f := range r.File </span><span class="cov0" title="0">{
                fpath = filepath.Join(dest, f.Name)
                if !strings.HasPrefix(fpath, filepath.Clean(dest)+string(os.PathSeparator)) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("illegal file path: %s", fpath)
                }</span>

                <span class="cov0" title="0">if f.FileInfo().IsDir() </span><span class="cov0" title="0">{
                        _, err = CustomMkdir(fpath)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if _, err = CustomMkdir(filepath.Dir(fpath)); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">outFile, err := os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">rc, err := f.Open()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">_, err = io.Copy(outFile, rc)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">err = outFile.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">err = rc.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        <span class="cov0" title="0">return fpath, nil</span>
}

func InstallBinary(tmpDirToolPath string) (string, error) <span class="cov0" title="0">{
        // Determine the destination path based on the operating system
        binaryName := filepath.Base(tmpDirToolPath)

        var destPath string
        switch HostOS.OS </span>{
        case "windows":<span class="cov0" title="0">
                destPath = filepath.Join(os.Getenv("ProgramFiles"), binaryName)</span>
        case "darwin", "linux":<span class="cov0" title="0">
                destPath = fmt.Sprintf("%s/%s", filepath.Join("/usr/local/bin"), binaryName)</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported operating system to install binary: %s/%s. Please open PR or let me know to fix it", HostOS.OS, HostOS.Arch)</span>
        }

        // Move the binary to the destination path
        <span class="cov0" title="0">if err := os.Rename(tmpDirToolPath, destPath); err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error moving binary to PATH. Maybe you need sudo?:", err)
                return "", fmt.Errorf("error moving binary to PATH: %v", err)
        }</span>

        // Make the binary executable (only needed for Unix-like systems)
        <span class="cov0" title="0">if HostOS.OS == "darwin" || HostOS.OS == "linux" </span><span class="cov0" title="0">{
                if err := os.Chmod(destPath, 0755); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error setting executable permissions:", err)
                        return "", fmt.Errorf("error setting executable permissions: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return destPath, nil</span>
}

func DownloadFromGithubAndInstall(tool string) (string, error) <span class="cov0" title="0">{
        tempDirPath, toolFullPath, err := FetchAndDownloadLatestVersionFromGitHub(tool)
        if err != nil </span><span class="cov0" title="0">{
                PrintCustomBiColourMsg("red", "cyan", "[-]", fmt.Sprintf("%s not found. Please install %s manually: %v", tool, tool, err))
                return "", fmt.Errorf("error downloading tool from github")
        }</span>

        <span class="cov0" title="0">PrintCustomBiColourMsg("green", "cyan", "[+] Successfully downloaded ", tool, " to ", toolFullPath)

        // Unzip the file
        extractedFilePath, err := Unzip(toolFullPath, tempDirPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error unzipping file:", err)
                return "", fmt.Errorf("error unzipping tool: %v", err)
        }</span>

        <span class="cov0" title="0">PrintCustomBiColourMsg("green", "cyan", "[+] Successfully unzipped ", tool, " to ", extractedFilePath)

        // Install it
        binaryPath, err := InstallBinary(extractedFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error installing %s: %v", tool, err)
        }</span>

        <span class="cov0" title="0">PrintCustomBiColourMsg("green", "cyan", "[+] Successfully installed ", tool, " in path directory: ", binaryPath)

        return binaryPath, nil</span>
}

// getLatestCondaVersion fetches the latest Conda version from the official Miniconda repository
func getLatestCondaVersion() (string, error) <span class="cov0" title="0">{
    url := "https://repo.anaconda.com/miniconda/"
    resp, err := http.Get(url)
    if err != nil </span><span class="cov0" title="0">{
        return "", err
    }</span>
    <span class="cov0" title="0">defer resp.Body.Close()

    tokenizer := html.NewTokenizer(resp.Body)
    for </span><span class="cov0" title="0">{
        tokenType := tokenizer.Next()
        if tokenType == html.ErrorToken </span><span class="cov0" title="0">{
            return "", fmt.Errorf("latest Conda version for %s %s not found. Please install conda manually: %s", HostOS.OS, HostOS.Arch, tokenizer.Err())
        }</span>
        <span class="cov0" title="0">token := tokenizer.Token()
        if tokenType == html.StartTagToken &amp;&amp; token.Data == "a" </span><span class="cov0" title="0">{
                        PrintCustomBiColourMsg("magenta", "yellow", "[?] Debug -&gt; ", fmt.Sprintf("%v\n", token))
            for _, attr := range token.Attr </span><span class="cov0" title="0">{
                                PrintCustomBiColourMsg("magenta", "yellow", "[?] Debug -&gt; ", attr.Key, " -&gt; ", attr.Val)
                                // Linux x86_64
                if HostOS.OS == "linux" &amp;&amp; HostOS.Arch == "amd64" &amp;&amp; attr.Key == "href" &amp;&amp; attr.Val == "Miniconda3-latest-Linux-x86_64.sh" </span><span class="cov0" title="0">{
                    return url + attr.Val, nil
                }</span>

                                // MacOSX arm64
                                <span class="cov0" title="0">if HostOS.OS == "darwin" &amp;&amp; HostOS.Arch == "arm64" &amp;&amp; attr.Key == "href" &amp;&amp; attr.Val == "Miniconda3-latest-MacOSX-arm64.sh" </span><span class="cov0" title="0">{
                                        return url + attr.Val, nil
                                }</span>

                                // MacOSX amd64
                                <span class="cov0" title="0">if HostOS.OS == "darwin" &amp;&amp; HostOS.Arch == "amd64" &amp;&amp; attr.Key == "href" &amp;&amp; attr.Val == "Miniconda3-latest-MacOSX-x86_64.sh" </span><span class="cov0" title="0">{
                                        return url + attr.Val, nil
                                }</span>

                                // Windows x86_64
                                <span class="cov0" title="0">if HostOS.OS == "windows" &amp;&amp; HostOS.Arch == "amd64" &amp;&amp; attr.Key == "href" &amp;&amp; attr.Val == "Miniconda3-latest-Windows-x86_64.exe" </span><span class="cov0" title="0">{
                                        return url + attr.Val, nil
                                }</span>
                        }
                }
        }
}

func InstallConda() error <span class="cov0" title="0">{
    latestVersionURL, err := getLatestCondaVersion()
    if err != nil </span><span class="cov0" title="0">{
        ErrorMsg(fmt.Sprintf("Error fetching latest Conda version: %v", err))
        return err
    }</span>
    <span class="cov0" title="0">fmt.Println("Found latest Conda installer version for host OS:", latestVersionURL)

        // Create an OS-agnostic temp directory for the tool
        toolTmpDir := filepath.Join(os.TempDir(), "conda")
        if err := os.MkdirAll(toolTmpDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while creating tmp dir: %v", err)
        }</span>

        <span class="cov0" title="0">fileName := strings.Split(latestVersionURL, "/")[len(strings.Split(latestVersionURL, "/"))-1]
        tmpFilePath := toolTmpDir + "/" + fileName
    err = DownloadFileFromURL(latestVersionURL, tmpFilePath)
    if err != nil </span><span class="cov0" title="0">{
        ErrorMsg(fmt.Sprintf("Error downloading file: %v", err))
        return fmt.Errorf("error downloading Conda installer: %v", err)
    }</span>
    <span class="cov0" title="0">fmt.Println("Downloaded file to:", toolTmpDir)
        PrintCustomBiColourMsg("magenta", "yellow", "[?] Debug -&gt; Downloaded file to: ", tmpFilePath)

        if HostOS.OS == "windows" </span><span class="cov0" title="0">{
                fmt.Println("Please run the installer manually. It can be found at:", tmpFilePath)
                return nil
        }</span>

        // Set executable permission
    <span class="cov0" title="0">err = os.Chmod(tmpFilePath, 0755)
    if err != nil </span><span class="cov0" title="0">{
        fmt.Println("Error setting executable permission:", err)
        return err
    }</span>
    <span class="cov0" title="0">fmt.Println("Executable permission set for:", tmpFilePath)

    // Run the binary
    cmd := exec.Command(tmpFilePath)
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
        cmd.Stdin = os.Stdin
    err = cmd.Run()
    if err != nil </span><span class="cov0" title="0">{
        fmt.Println("Error running binary:", err)
        return err
    }</span>
    <span class="cov0" title="0">fmt.Println("Binary executed successfully")

        PrintCustomBiColourMsg("green", "cyan", "[+] Successfully installed ", "Conda", ".")
        return nil</span>
}

func CheckAdminPrivileges(cloudOrInfra string) <span class="cov0" title="0">{
        switch cloudOrInfra </span>{
        case "cloud":<span class="cov0" title="0">
                switch HostOS.OS </span>{
                case "windows":<span class="cov0" title="0">
                        // Check for administrative privileges on Windows
                        cmd := exec.Command("powershell", "-Command", "[Security.Principal.WindowsPrincipal]::new([Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)")
                        output, err := cmd.Output()
                        if err != nil || string(output) != "True\n" </span><span class="cov0" title="0">{
                                ErrorMsg("Windows detected. If the program fails, please, run it as administrator so logic like tools installation doesn't fail!")
                        }</span>
                case "linux", "darwin":<span class="cov0" title="0">
                        // Check for root privileges on Unix-like systems
                        if os.Geteuid() != 0 </span><span class="cov0" title="0">{
                                ErrorMsg("Please run me as root so the tools don't fail!")
                                // os.Exit(99)
                        }</span>
                default:<span class="cov0" title="0">
                        ErrorMsg("Unsupported operating system")
                        os.Exit(99)</span>
                }
        case "infra":<span class="cov0" title="0">
                switch HostOS.OS </span>{
                case "windows":<span class="cov0" title="0">
                        // Windows not supported for infra scanning
                        ErrorMsg("Windows detected. For now running the infra section of Enumeraga in Windows isn't supported. Should you wish to contribute or formally request it, please get in touch or open a PR.")
                        os.Exit(99)</span>
                case "linux", "darwin":<span class="cov0" title="0">
                        // Check for root privileges on Unix-like systems
                        if os.Geteuid() != 0 </span><span class="cov0" title="0">{
                                ErrorMsg("Please run me as root so the tools don't fail!")
                                // os.Exit(99)
                        }</span>
                default:<span class="cov0" title="0">
                        ErrorMsg("Unsupported operating system")
                        os.Exit(99)</span>
                }
        default:<span class="cov0" title="0">
                ErrorMsg(fmt.Sprintf("Unknown mode: %s. Expected 'cloud' or 'infra'", cloudOrInfra))
                os.Exit(99)</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "fmt"
        "net"
        "strings"
        "time"
        "unicode"

        "github.com/0x5ubt13/enumeraga/internal/checks"
        "github.com/0x5ubt13/enumeraga/internal/commands"
        "github.com/0x5ubt13/enumeraga/internal/portsIterator"
        "github.com/0x5ubt13/enumeraga/internal/scans"
        "github.com/0x5ubt13/enumeraga/internal/utils"
        "github.com/Ullaakut/nmap/v3"
)

// Main logic of Enumeraga infra
func main() <span class="cov0" title="0">{
        fmt.Println("----------\n[!] WARNING: \nYou're running a version currently under beta development. \nPlease use the latest pre-compiled version of Enumeraga in the official repo instead (unless you're helping me debug).\nThanks!\n----------")

        // Perform pre-flight checks and get number of lines if cloud logic hasn't kicked off.
        totalLines := checks.Run()

        // Timing the execution
        start := time.Now()

        // Cidr handling
        cidrErr := cidrInit()
        if cidrErr != nil </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("yellow", "red", "[!] CIDR range ", "NOT ", "detected. Aborting CIDR enumeration for this run")
                utils.PrintCustomBiColourMsg("cyan", "yellow", "[*] Remember you can also pass a range in ", "CIDR notation ", "to use ", "enum tools ", "that scan a wide range with '", "-r", "'")
        }</span>

        <span class="cov0" title="0">if !*checks.OptQuiet </span><span class="cov0" title="0">{
                fmt.Printf("%s%s%s\n\n", utils.Cyan("[*] ---------- "), utils.Green("Checks phase complete"), utils.Cyan(" ----------"))
                fmt.Printf("%s%s%s\n", utils.Cyan("[*] ---------- "), utils.Green("Starting enumeration phase"), utils.Cyan(" ----------"))
        }</span>

        // Main flow
        <span class="cov0" title="0">flowErr := targetInit(totalLines)
        if flowErr != nil </span><span class="cov0" title="0">{
                utils.ErrorMsg(fmt.Sprintf("%s", flowErr))
        }</span>

        // Finish and show elapsed time
        <span class="cov0" title="0">utils.FinishLine(start, utils.Interrupted)

        // Wait for goroutines to finish to terminate the program
        utils.Wg.Wait()</span>
}

// Check whether a target CIDR range has been passed to Enumeraga
func cidrInit() error <span class="cov0" title="0">{
        if *checks.OptRange != "" </span><span class="cov0" title="0">{
                commands.RunRangeTools(*checks.OptRange, checks.OptVVerbose, checks.OptOutput)
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("CIDR range target not passed to Enumeraga")</span>
}

// Start of main flow:
// Check total number of lines to select targets accordingly
func targetInit(totalLines int) error <span class="cov0" title="0">{
        // If bruteforce flag was passed, initialise the wordlists
        if *checks.OptBrute &amp;&amp; !*checks.OptNmapOnly </span><span class="cov0" title="0">{
                if !*checks.OptQuiet </span><span class="cov0" title="0">{
                        fmt.Printf("%s\n", utils.Cyan("[*] Bruteforce flag detected. Activating fuzzing and bruteforce tools where applicable."))
                }</span>
                <span class="cov0" title="0">utils.GetWordlists(checks.OptVVerbose)</span>
        }

        // If not single target, initialise multi target flow
        <span class="cov0" title="0">if totalLines != 0 </span><span class="cov0" title="0">{
                multiTarget(checks.OptTarget)
                return nil
        }</span>

        // If made it this far, run single target scan
        <span class="cov0" title="0">err := singleTarget(*checks.OptTarget, *checks.OptOutput)
        if err != nil </span><span class="cov0" title="0">{
                utils.Interrupted = true
                return err
        }</span>

        <span class="cov0" title="0">utils.PrintCustomBiColourMsg("green", "yellow", "[+] Done! All well-known ports included in Enumeraga for '", utils.Target, "' were successfully parsed.")

        return nil</span>
}

func sweepPorts() ([]nmap.Host, []nmap.Host) <span class="cov0" title="0">{
        // If top ports flag passed, branch to use a common ports scan instead
        if *checks.OptTopPorts != "" </span><span class="cov0" title="0">{
                return scans.TcpPortSweepWithTopPorts(utils.Target, checks.OptTopPorts, checks.OptVVerbose),
                        scans.UdpPortSweep(utils.Target, checks.OptVVerbose)
        }</span>

        <span class="cov0" title="0">if utils.TimesSwept == 0 </span><span class="cov0" title="0">{
                return scans.TcpPortSweep(utils.Target, checks.OptVVerbose), scans.UdpPortSweep(utils.Target, checks.OptVVerbose)
        }</span>

        <span class="cov0" title="0">return scans.SlowerTcpPortSweep(utils.Target, checks.OptVVerbose), scans.SlowerUdpPortSweep(utils.Target, checks.OptVVerbose)</span>
}

// Run all phases of scanning using a single target
func singleTarget(target string, baseFilePath string) error <span class="cov0" title="0">{
        // Clean up trailing not alphanumeric characters in target
        target = strings.TrimFunc(target, func(r rune) bool </span><span class="cov0" title="0">{
                return !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r) &amp;&amp; r != '.' &amp;&amp; r != '-'
        }</span>)

        // Validate target is not empty after trimming
        <span class="cov0" title="0">if target == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("target is empty after sanitization")
        }</span>

        <span class="cov0" title="0">utils.Target = target

        // Make base dir for the target
        targetPath := fmt.Sprintf("%s/%s/", baseFilePath, target)
        _, err := utils.CustomMkdir(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                if *checks.OptVVerbose </span><span class="cov0" title="0">{
                        utils.ErrorMsg(err)
                }</span>
        }

        // Perform ports sweep
        <span class="cov0" title="0">utils.PrintCustomBiColourMsg("cyan", "yellow", "[*] Sweeping TCP and UDP ports on target '", target, "'...")
        sweptHostTcp, sweptHostUdp := sweepPorts()

        // Save open ports in dedicated slice
        // Convert slice to nmap-friendly formatted numbers
        openPortsSlice := utils.GetOpenPortsSlice(sweptHostTcp, sweptHostUdp)

        // Join our string slice for printing purposes
        openPorts := utils.RemoveDuplicates(strings.Join(openPortsSlice, ","))

        // Introducing a control to repeat the scan in case there are no ports or there is only one port open
        // Do it only once
        if len(openPorts) &lt;= 1 &amp;&amp; utils.TimesSwept == 1 </span><span class="cov0" title="0">{
                sweptHostTcpSecond, sweptHostUdpSecond := sweepPorts()
                openPortsSliceSecondTry := utils.GetOpenPortsSlice(sweptHostTcpSecond, sweptHostUdpSecond)

                if len(openPortsSliceSecondTry) &gt; len(openPortsSlice) </span><span class="cov0" title="0">{
                        openPorts = utils.RemoveDuplicates(strings.Join(openPortsSliceSecondTry, ","))
                        utils.PrintCustomBiColourMsg("cyan", "yellow", "[*] More ports found in the second slow run for target '", target, "'.")
                }</span> else<span class="cov0" title="0"> {
                        utils.PrintCustomBiColourMsg("cyan", "yellow", "[*] No further ports were found in the second slow run for target '", target, "'.")
                }</span>
        }

        <span class="cov0" title="0">if len(openPorts) &gt; 0 </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("green", "cyan", "[+] Open ports for target '", target, "' : ", openPorts)
                if _, err := utils.WritePortsToFile(targetPath, openPorts, target); err != nil </span><span class="cov0" title="0">{
                        utils.ErrorMsg(fmt.Sprintf("Failed to write ports to file: %v", err))
                }</span>

                // Launch main aggressive nmap scan in parallel that covers all open ports found
                <span class="cov0" title="0">outFile := targetPath + "aggressive_scan"
                commands.CallFullAggressiveScan(target, openPorts, outFile, checks.OptVVerbose)</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("no ports were found open")
        }</span>

        // Run ports iterator with the open ports found if nmap only flag not passed
        <span class="cov0" title="0">if *checks.OptNmapOnly </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">utils.BaseDir = targetPath
        portsIterator.Run(openPortsSlice)

        return nil</span>
}

// Wrapper of single target for multi-target
func multiTarget(targetsFile *string) <span class="cov0" title="0">{
        if !*checks.OptQuiet </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("green", "yellow", "[+] Using multi-targets file: '", *targetsFile, "'")
        }</span>

        <span class="cov0" title="0">fileNameWithExtension := strings.Split(*targetsFile, "/")
        fileName := strings.Split(fileNameWithExtension[len(fileNameWithExtension)-1], ".")

        // Make base folder for the output
        targetsBaseFilePath := fmt.Sprintf("%s/%s", *checks.OptOutput, fileName[0])
        _, err := utils.CustomMkdir(targetsBaseFilePath)
        if err != nil </span><span class="cov0" title="0">{
                if *checks.OptVVerbose </span><span class="cov0" title="0">{
                        utils.ErrorMsg(err)
                }</span>
        }

        // Loop through the targets in the file
        <span class="cov0" title="0">targets, lines := utils.ReadTargetsFile(checks.OptTarget)
        if !*checks.OptQuiet </span><span class="cov0" title="0">{
                utils.PrintCustomBiColourMsg("green", "yellow", "[+] Found ", fmt.Sprintf("%d", lines), " targets")
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; lines; i++ </span><span class="cov0" title="0">{
                target := targets[i]

                // Clean up trailing not alphanumeric characters in target
                target = strings.TrimFunc(target, func(r rune) bool </span><span class="cov0" title="0">{
                        return !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r) &amp;&amp; r != '.' &amp;&amp; r != '-' &amp;&amp; r != ':'
                }</span>)

                // Skip empty targets after sanitization
                <span class="cov0" title="0">if target == "" </span><span class="cov0" title="0">{
                        utils.PrintCustomBiColourMsg("yellow", "red", "[!] Skipping empty target at line ", fmt.Sprint(i+1))
                        continue</span>
                }

                // Try to resolve hostname/URL to IP if it's not already an IP
                <span class="cov0" title="0">resolvedTarget := target
                if ip := strings.TrimSpace(target); ip != "" </span><span class="cov0" title="0">{
                        // Check if it's not already an IP address
                        if net.ParseIP(ip) == nil </span><span class="cov0" title="0">{
                                // Try to resolve as hostname/URL
                                if resolvedIP, err := utils.ResolveHostToIP(ip); err == nil </span><span class="cov0" title="0">{
                                        utils.PrintCustomBiColourMsg("green", "cyan", "[+] Resolved hostname '", target, "' to IP: ", resolvedIP)
                                        resolvedTarget = resolvedIP
                                }</span> else<span class="cov0" title="0"> {
                                        utils.PrintCustomBiColourMsg("red", "yellow", "[-] Failed to resolve hostname '", target, "': ", err.Error())
                                        continue</span>
                                }
                        }
                }

                // Launch enumeration for the target
                <span class="cov0" title="0">utils.PrintCustomBiColourMsg("green", "yellow", "[+] Attacking target ", fmt.Sprint(i+1), " of ", fmt.Sprint(lines), ": ", resolvedTarget)
                err := singleTarget(resolvedTarget, targetsBaseFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        utils.PrintCustomBiColourMsg("red", "yellow", "[-] No open ports were found in host '", resolvedTarget, "'. Aborting the rest of scans for this host")
                        continue</span>
                }

                <span class="cov0" title="0">utils.PrintCustomBiColourMsg("green", "yellow", "[+] Done! All well-known ports included in Enumeraga for '", resolvedTarget, "' were successfully parsed.")</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
